     

-   [](../../index.html)
-   [Implementations](../../implementations.html)
-   [C++ Implementation](../index.html)
-   [API Reference](../api.html)
-   Data Types

:::::::::::::: section
# Data Types[\#](#data-types)

enum arrow::Type::type[\#](#_CPPv4N5arrow4Type4typeE)\

:   Main data type enumeration.

    This enumeration provides a quick way to interrogate the category of
    a [DataType](#classarrow_1_1_data_type) instance.

    *Values:*

    enumerator NA[\#](#_CPPv4N5arrow4Type4type2NAE)\

    :   A NULL type having no physical storage.

    enumerator BOOL[\#](#_CPPv4N5arrow4Type4type4BOOLE)\

    :   Boolean as 1 bit, LSB bit-packed ordering.

    enumerator UINT8[\#](#_CPPv4N5arrow4Type4type5UINT8E)\

    :   Unsigned 8-bit little-endian integer.

    enumerator INT8[\#](#_CPPv4N5arrow4Type4type4INT8E)\

    :   Signed 8-bit little-endian integer.

    enumerator UINT16[\#](#_CPPv4N5arrow4Type4type6UINT16E)\

    :   Unsigned 16-bit little-endian integer.

    enumerator INT16[\#](#_CPPv4N5arrow4Type4type5INT16E)\

    :   Signed 16-bit little-endian integer.

    enumerator UINT32[\#](#_CPPv4N5arrow4Type4type6UINT32E)\

    :   Unsigned 32-bit little-endian integer.

    enumerator INT32[\#](#_CPPv4N5arrow4Type4type5INT32E)\

    :   Signed 32-bit little-endian integer.

    enumerator UINT64[\#](#_CPPv4N5arrow4Type4type6UINT64E)\

    :   Unsigned 64-bit little-endian integer.

    enumerator INT64[\#](#_CPPv4N5arrow4Type4type5INT64E)\

    :   Signed 64-bit little-endian integer.

    enumerator HALF_FLOAT[\#](#_CPPv4N5arrow4Type4type10HALF_FLOATE)\

    :   2-byte floating point value

    enumerator FLOAT[\#](#_CPPv4N5arrow4Type4type5FLOATE)\

    :   4-byte floating point value

    enumerator DOUBLE[\#](#_CPPv4N5arrow4Type4type6DOUBLEE)\

    :   8-byte floating point value

    enumerator STRING[\#](#_CPPv4N5arrow4Type4type6STRINGE)\

    :   UTF8 variable-length string as List\<Char\>

    enumerator BINARY[\#](#_CPPv4N5arrow4Type4type6BINARYE)\

    :   Variable-length bytes (no guarantee of UTF8-ness)

    enumerator FIXED_SIZE_BINARY[\#](#_CPPv4N5arrow4Type4type17FIXED_SIZE_BINARYE)\

    :   Fixed-size binary. Each value occupies the same number of bytes.

    enumerator DATE32[\#](#_CPPv4N5arrow4Type4type6DATE32E)\

    :   int32_t days since the UNIX epoch

    enumerator DATE64[\#](#_CPPv4N5arrow4Type4type6DATE64E)\

    :   int64_t milliseconds since the UNIX epoch

    enumerator TIMESTAMP[\#](#_CPPv4N5arrow4Type4type9TIMESTAMPE)\

    :   Exact timestamp encoded with int64 since UNIX epoch Default unit
        millisecond.

    enumerator TIME32[\#](#_CPPv4N5arrow4Type4type6TIME32E)\

    :   Time as signed 32-bit integer, representing either seconds or
        milliseconds since midnight.

    enumerator TIME64[\#](#_CPPv4N5arrow4Type4type6TIME64E)\

    :   Time as signed 64-bit integer, representing either microseconds
        or nanoseconds since midnight.

    enumerator INTERVAL_MONTHS[\#](#_CPPv4N5arrow4Type4type15INTERVAL_MONTHSE)\

    :   YEAR_MONTH interval in SQL style.

    enumerator INTERVAL_DAY_TIME[\#](#_CPPv4N5arrow4Type4type17INTERVAL_DAY_TIMEE)\

    :   DAY_TIME interval in SQL style.

    enumerator DECIMAL128[\#](#_CPPv4N5arrow4Type4type10DECIMAL128E)\

    :   Precision- and scale-based decimal type with 128 bits.

    enumerator DECIMAL[\#](#_CPPv4N5arrow4Type4type7DECIMALE)\

    :   Defined for backward-compatibility.

    enumerator DECIMAL256[\#](#_CPPv4N5arrow4Type4type10DECIMAL256E)\

    :   Precision- and scale-based decimal type with 256 bits.

    enumerator LIST[\#](#_CPPv4N5arrow4Type4type4LISTE)\

    :   A list of some logical data type.

    enumerator STRUCT[\#](#_CPPv4N5arrow4Type4type6STRUCTE)\

    :   Struct of logical types.

    enumerator SPARSE_UNION[\#](#_CPPv4N5arrow4Type4type12SPARSE_UNIONE)\

    :   Sparse unions of logical types.

    enumerator DENSE_UNION[\#](#_CPPv4N5arrow4Type4type11DENSE_UNIONE)\

    :   Dense unions of logical types.

    enumerator DICTIONARY[\#](#_CPPv4N5arrow4Type4type10DICTIONARYE)\

    :   Dictionary-encoded type, also called "categorical" or "factor"
        in other programming languages.

        Holds the dictionary value type but not the dictionary itself,
        which is part of the
        [ArrayData](array.html#structarrow_1_1_array_data) struct

    enumerator MAP[\#](#_CPPv4N5arrow4Type4type3MAPE)\

    :   Map, a repeated struct logical type.

    enumerator EXTENSION[\#](#_CPPv4N5arrow4Type4type9EXTENSIONE)\

    :   Custom data type, implemented by user.

    enumerator FIXED_SIZE_LIST[\#](#_CPPv4N5arrow4Type4type15FIXED_SIZE_LISTE)\

    :   Fixed size list of some logical type.

    enumerator DURATION[\#](#_CPPv4N5arrow4Type4type8DURATIONE)\

    :   Measure of elapsed time in either seconds, milliseconds,
        microseconds or nanoseconds.

    enumerator LARGE_STRING[\#](#_CPPv4N5arrow4Type4type12LARGE_STRINGE)\

    :   Like STRING, but with 64-bit offsets.

    enumerator LARGE_BINARY[\#](#_CPPv4N5arrow4Type4type12LARGE_BINARYE)\

    :   Like BINARY, but with 64-bit offsets.

    enumerator LARGE_LIST[\#](#_CPPv4N5arrow4Type4type10LARGE_LISTE)\

    :   Like LIST, but with 64-bit offsets.

    enumerator INTERVAL_MONTH_DAY_NANO[\#](#_CPPv4N5arrow4Type4type23INTERVAL_MONTH_DAY_NANOE)\

    :   Calendar interval type with three fields.

    enumerator RUN_END_ENCODED[\#](#_CPPv4N5arrow4Type4type15RUN_END_ENCODEDE)\

    :   Run-end encoded data.

    enumerator STRING_VIEW[\#](#_CPPv4N5arrow4Type4type11STRING_VIEWE)\

    :   String (UTF8) view type with 4-byte prefix and inline small
        string optimization.

    enumerator BINARY_VIEW[\#](#_CPPv4N5arrow4Type4type11BINARY_VIEWE)\

    :   Bytes view type with 4-byte prefix and inline small string
        optimization.

    enumerator LIST_VIEW[\#](#_CPPv4N5arrow4Type4type9LIST_VIEWE)\

    :   A list of some logical data type represented by offset and size.

    enumerator LARGE_LIST_VIEW[\#](#_CPPv4N5arrow4Type4type15LARGE_LIST_VIEWE)\

    :   Like LIST_VIEW, but with 64-bit offsets and sizes.

    enumerator DECIMAL32[\#](#_CPPv4N5arrow4Type4type9DECIMAL32E)\

    :   Precision- and scale-based decimal type with 32 bits.

    enumerator DECIMAL64[\#](#_CPPv4N5arrow4Type4type9DECIMAL64E)\

    :   Precision- and scale-based decimal type with 64 bits.

    enumerator MAX_ID[\#](#_CPPv4N5arrow4Type4type6MAX_IDE)\

    :   

<!-- -->

class DataType : public std::enable_shared_from_this\<[DataType](#_CPPv4N5arrow8DataTypeE)\>, public arrow::detail::Fingerprintable, public arrow::util::EqualityComparable\<[DataType](#_CPPv4N5arrow8DataTypeE)\>[\#](#_CPPv4N5arrow8DataTypeE)\

:   Base class for all data types.

    Data types in this library are all *logical*. They can be expressed
    as either a primitive physical type (bytes or bits of some fixed
    size), a nested type consisting of other data types, or another data
    type (e.g. a timestamp encoded as an int64).

    Simple datatypes may be entirely described by their
    [Type::type](#structarrow_1_1_type_1a00a041cb19a3be373da8eec7d4bf1f44)
    id, but complex datatypes are usually parametric.

    Subclassed by arrow::BaseBinaryType,
    [arrow::BinaryViewType](#classarrow_1_1_binary_view_type),
    [arrow::ExtensionType](#classarrow_1_1_extension_type),
    arrow::FixedWidthType, arrow::NestedType,
    [arrow::NullType](#classarrow_1_1_null_type)

    Public Functions

    bool Equals(const [DataType](#_CPPv4N5arrow8DataTypeE) &other, bool check_metadata = false) const[\#](#_CPPv4NK5arrow8DataType6EqualsERK8DataTypeb)\

    :   Return whether the types are equal.

        Types that are logically convertible from one to another (e.g.
        List\<UInt8\> and Binary) are NOT equal.

    <!-- -->

    bool Equals(const std::shared_ptr\<[DataType](#_CPPv4N5arrow8DataTypeE)\> &other, bool check_metadata = false) const[\#](#_CPPv4NK5arrow8DataType6EqualsERKNSt10shared_ptrI8DataTypeEEb)\

    :   Return whether the types are equal.

    <!-- -->

    inline const std::shared_ptr\<[Field](#_CPPv4N5arrow5FieldE)\> &field(int i) const[\#](#_CPPv4NK5arrow8DataType5fieldEi)\

    :   Return the child field at index i.

    <!-- -->

    inline const FieldVector &fields() const[\#](#_CPPv4NK5arrow8DataType6fieldsEv)\

    :   Return the children fields associated with this type.

    <!-- -->

    inline int num_fields() const[\#](#_CPPv4NK5arrow8DataType10num_fieldsEv)\

    :   Return the number of children fields associated with this type.

    <!-- -->

    [Status](support.html#_CPPv4N5arrow6StatusE) Accept([TypeVisitor](#_CPPv4N5arrow11TypeVisitorE) \*visitor) const[\#](#_CPPv4NK5arrow8DataType6AcceptEP11TypeVisitor)\

    :   Apply the
        [TypeVisitor::Visit()](#classarrow_1_1_type_visitor_1a7c55beece55f9c82a191a3667f2ca582)
        method specialized to the data type.

    <!-- -->

    virtual std::string ToString(bool show_metadata = false) const = 0[\#](#_CPPv4NK5arrow8DataType8ToStringEb)\

    :   A string representation of the type, including any children.

    <!-- -->

    size_t Hash() const[\#](#_CPPv4NK5arrow8DataType4HashEv)\

    :   Return hash value (excluding metadata in child fields)

    <!-- -->

    virtual std::string name() const = 0[\#](#_CPPv4NK5arrow8DataType4nameEv)\

    :   A string name of the type, omitting any child fields.

        **Since**

        :   0.7.0

    <!-- -->

    virtual DataTypeLayout layout() const = 0[\#](#_CPPv4NK5arrow8DataType6layoutEv)\

    :   Return the data type layout.

        Children are not included.

        Note

        Experimental API

    <!-- -->

    inline constexpr Type::[type](#_CPPv4N5arrow4Type4typeE) id() const[\#](#_CPPv4NK5arrow8DataType2idEv)\

    :   Return the type category.

    <!-- -->

    inline virtual Type::[type](#_CPPv4N5arrow4Type4typeE) storage_id() const[\#](#_CPPv4NK5arrow8DataType10storage_idEv)\

    :   Return the type category of the storage type.

    <!-- -->

    inline virtual int32_t byte_width() const[\#](#_CPPv4NK5arrow8DataType10byte_widthEv)\

    :   Returns the type's fixed byte width, if any.

        Returns -1 for non-fixed-width types, and should only be used
        for subclasses of FixedWidthType

    <!-- -->

    inline virtual int bit_width() const[\#](#_CPPv4NK5arrow8DataType9bit_widthEv)\

    :   Returns the type's fixed bit width, if any.

        Returns -1 for non-fixed-width types, and should only be used
        for subclasses of FixedWidthType

::: section

## Factory functions[\#](#factory-functions)

These functions are recommended for creating data types. They may return
new objects or existing singletons, depending on the type requested.

const std::shared_ptr\<DataType\> &null()[\#](#_CPPv44nullv)\

:   Return a [NullType](#classarrow_1_1_null_type) instance.

<!-- -->

const std::shared_ptr\<DataType\> &boolean()[\#](#_CPPv47booleanv)\

:   Return a [BooleanType](#classarrow_1_1_boolean_type) instance.

<!-- -->

const std::shared_ptr\<DataType\> &int8()[\#](#_CPPv44int8v)\

:   Return a [Int8Type](#classarrow_1_1_int8_type) instance.

<!-- -->

const std::shared_ptr\<DataType\> &int16()[\#](#_CPPv45int16v)\

:   Return a [Int16Type](#classarrow_1_1_int16_type) instance.

<!-- -->

const std::shared_ptr\<DataType\> &int32()[\#](#_CPPv45int32v)\

:   Return a [Int32Type](#classarrow_1_1_int32_type) instance.

<!-- -->

const std::shared_ptr\<DataType\> &int64()[\#](#_CPPv45int64v)\

:   Return a [Int64Type](#classarrow_1_1_int64_type) instance.

<!-- -->

const std::shared_ptr\<DataType\> &uint8()[\#](#_CPPv45uint8v)\

:   Return a [UInt8Type](#classarrow_1_1_u_int8_type) instance.

<!-- -->

const std::shared_ptr\<DataType\> &uint16()[\#](#_CPPv46uint16v)\

:   Return a [UInt16Type](#classarrow_1_1_u_int16_type) instance.

<!-- -->

const std::shared_ptr\<DataType\> &uint32()[\#](#_CPPv46uint32v)\

:   Return a [UInt32Type](#classarrow_1_1_u_int32_type) instance.

<!-- -->

const std::shared_ptr\<DataType\> &uint64()[\#](#_CPPv46uint64v)\

:   Return a [UInt64Type](#classarrow_1_1_u_int64_type) instance.

<!-- -->

const std::shared_ptr\<DataType\> &float16()[\#](#_CPPv47float16v)\

:   Return a [HalfFloatType](#classarrow_1_1_half_float_type) instance.

<!-- -->

const std::shared_ptr\<DataType\> &float32()[\#](#_CPPv47float32v)\

:   Return a [FloatType](#classarrow_1_1_float_type) instance.

<!-- -->

const std::shared_ptr\<DataType\> &float64()[\#](#_CPPv47float64v)\

:   Return a [DoubleType](#classarrow_1_1_double_type) instance.

<!-- -->

const std::shared_ptr\<DataType\> &utf8()[\#](#_CPPv44utf8v)\

:   Return a [StringType](#classarrow_1_1_string_type) instance.

<!-- -->

const std::shared_ptr\<DataType\> &utf8_view()[\#](#_CPPv49utf8_viewv)\

:   Return a [StringViewType](#classarrow_1_1_string_view_type)
    instance.

<!-- -->

const std::shared_ptr\<DataType\> &large_utf8()[\#](#_CPPv410large_utf8v)\

:   Return a [LargeStringType](#classarrow_1_1_large_string_type)
    instance.

<!-- -->

const std::shared_ptr\<DataType\> &binary()[\#](#_CPPv46binaryv)\

:   Return a [BinaryType](#classarrow_1_1_binary_type) instance.

<!-- -->

const std::shared_ptr\<DataType\> &binary_view()[\#](#_CPPv411binary_viewv)\

:   Return a [BinaryViewType](#classarrow_1_1_binary_view_type)
    instance.

<!-- -->

const std::shared_ptr\<DataType\> &large_binary()[\#](#_CPPv412large_binaryv)\

:   Return a [LargeBinaryType](#classarrow_1_1_large_binary_type)
    instance.

<!-- -->

const std::shared_ptr\<DataType\> &date32()[\#](#_CPPv46date32v)\

:   Return a [Date32Type](#classarrow_1_1_date32_type) instance.

<!-- -->

const std::shared_ptr\<DataType\> &date64()[\#](#_CPPv46date64v)\

:   Return a [Date64Type](#classarrow_1_1_date64_type) instance.

<!-- -->

std::shared_ptr\<DataType\> fixed_size_binary(int32_t byte_width)[\#](#_CPPv417fixed_size_binary7int32_t)\

:   Create a
    [FixedSizeBinaryType](#classarrow_1_1_fixed_size_binary_type)
    instance.

<!-- -->

std::shared_ptr\<DataType\> decimal(int32_t precision, int32_t scale)[\#](#_CPPv47decimal7int32_t7int32_t)\

:   Create a [DecimalType](#classarrow_1_1_decimal_type) instance
    depending on the precision.

    If the precision is greater than 38, a
    [Decimal256Type](#classarrow_1_1_decimal256_type) is returned,
    otherwise a [Decimal128Type](#classarrow_1_1_decimal128_type).

    Deprecated: prefer `smallest_decimal` instead.

<!-- -->

std::shared_ptr\<DataType\> smallest_decimal(int32_t precision, int32_t scale)[\#](#_CPPv416smallest_decimal7int32_t7int32_t)\

:   Create a the smallest [DecimalType](#classarrow_1_1_decimal_type)
    instance depending on precision.

    Given the requested precision and scale, the smallest
    [DecimalType](#classarrow_1_1_decimal_type) which is able to
    represent that precision will be returned. As different bit-widths
    for decimal types are added, the concrete data type returned here
    can potentially change accordingly.

<!-- -->

std::shared_ptr\<DataType\> decimal32(int32_t precision, int32_t scale)[\#](#_CPPv49decimal327int32_t7int32_t)\

:   Create a [Decimal32Type](#classarrow_1_1_decimal32_type) instance.

<!-- -->

std::shared_ptr\<DataType\> decimal64(int32_t precision, int32_t scale)[\#](#_CPPv49decimal647int32_t7int32_t)\

:   Create a [Decimal64Type](#classarrow_1_1_decimal64_type) instance.

<!-- -->

std::shared_ptr\<DataType\> decimal128(int32_t precision, int32_t scale)[\#](#_CPPv410decimal1287int32_t7int32_t)\

:   Create a [Decimal128Type](#classarrow_1_1_decimal128_type) instance.

<!-- -->

std::shared_ptr\<DataType\> decimal256(int32_t precision, int32_t scale)[\#](#_CPPv410decimal2567int32_t7int32_t)\

:   Create a [Decimal256Type](#classarrow_1_1_decimal256_type) instance.

<!-- -->

std::shared_ptr\<DataType\> list(std::shared_ptr\<Field\> value_type)[\#](#_CPPv44listNSt10shared_ptrI5FieldEE)\

:   Create a [ListType](#classarrow_1_1_list_type) instance from its
    child [Field](#classarrow_1_1_field) type.

<!-- -->

std::shared_ptr\<DataType\> list(std::shared_ptr\<DataType\> value_type)[\#](#_CPPv44listNSt10shared_ptrI8DataTypeEE)\

:   Create a [ListType](#classarrow_1_1_list_type) instance from its
    child [DataType](#classarrow_1_1_data_type).

<!-- -->

std::shared_ptr\<DataType\> large_list(std::shared_ptr\<Field\> value_type)[\#](#_CPPv410large_listNSt10shared_ptrI5FieldEE)\

:   Create a [LargeListType](#classarrow_1_1_large_list_type) instance
    from its child [Field](#classarrow_1_1_field) type.

<!-- -->

std::shared_ptr\<DataType\> large_list(std::shared_ptr\<DataType\> value_type)[\#](#_CPPv410large_listNSt10shared_ptrI8DataTypeEE)\

:   Create a [LargeListType](#classarrow_1_1_large_list_type) instance
    from its child [DataType](#classarrow_1_1_data_type).

<!-- -->

std::shared_ptr\<DataType\> list_view(std::shared_ptr\<DataType\> value_type)[\#](#_CPPv49list_viewNSt10shared_ptrI8DataTypeEE)\

:   Create a [ListViewType](#classarrow_1_1_list_view_type) instance.

<!-- -->

std::shared_ptr\<DataType\> list_view(std::shared_ptr\<Field\> value_type)[\#](#_CPPv49list_viewNSt10shared_ptrI5FieldEE)\

:   Create a [ListViewType](#classarrow_1_1_list_view_type) instance
    from its child [Field](#classarrow_1_1_field) type.

<!-- -->

std::shared_ptr\<DataType\> large_list_view(std::shared_ptr\<DataType\> value_type)[\#](#_CPPv415large_list_viewNSt10shared_ptrI8DataTypeEE)\

:   Create a LargetListViewType instance.

<!-- -->

std::shared_ptr\<DataType\> large_list_view(std::shared_ptr\<Field\> value_type)[\#](#_CPPv415large_list_viewNSt10shared_ptrI5FieldEE)\

:   Create a LargetListViewType instance from its child
    [Field](#classarrow_1_1_field) type.

<!-- -->

std::shared_ptr\<DataType\> map(std::shared_ptr\<DataType\> key_type, std::shared_ptr\<DataType\> item_type, bool keys_sorted = false)[\#](#_CPPv43mapNSt10shared_ptrI8DataTypeEENSt10shared_ptrI8DataTypeEEb)\

:   Create a [MapType](#classarrow_1_1_map_type) instance from its key
    and value DataTypes.

<!-- -->

std::shared_ptr\<DataType\> map(std::shared_ptr\<DataType\> key_type, std::shared_ptr\<Field\> item_field, bool keys_sorted = false)[\#](#_CPPv43mapNSt10shared_ptrI8DataTypeEENSt10shared_ptrI5FieldEEb)\

:   Create a [MapType](#classarrow_1_1_map_type) instance from its key
    [DataType](#classarrow_1_1_data_type) and value field.

    The field override is provided to communicate nullability of the
    value.

<!-- -->

std::shared_ptr\<DataType\> fixed_size_list(std::shared_ptr\<Field\> value_type, int32_t list_size)[\#](#_CPPv415fixed_size_listNSt10shared_ptrI5FieldEE7int32_t)\

:   Create a [FixedSizeListType](#classarrow_1_1_fixed_size_list_type)
    instance from its child [Field](#classarrow_1_1_field) type.

<!-- -->

std::shared_ptr\<DataType\> fixed_size_list(std::shared_ptr\<DataType\> value_type, int32_t list_size)[\#](#_CPPv415fixed_size_listNSt10shared_ptrI8DataTypeEE7int32_t)\

:   Create a [FixedSizeListType](#classarrow_1_1_fixed_size_list_type)
    instance from its child [DataType](#classarrow_1_1_data_type).

<!-- -->

std::shared_ptr\<DataType\> duration(TimeUnit::type unit)[\#](#_CPPv48durationN8TimeUnit4typeE)\

:   Return a Duration instance (naming use \_type to avoid namespace
    conflict with built in time classes).

<!-- -->

std::shared_ptr\<DataType\> day_time_interval()[\#](#_CPPv417day_time_intervalv)\

:   Return a
    [DayTimeIntervalType](#classarrow_1_1_day_time_interval_type)
    instance.

<!-- -->

std::shared_ptr\<DataType\> month_interval()[\#](#_CPPv414month_intervalv)\

:   Return a [MonthIntervalType](#classarrow_1_1_month_interval_type)
    instance.

<!-- -->

std::shared_ptr\<DataType\> month_day_nano_interval()[\#](#_CPPv423month_day_nano_intervalv)\

:   Return a
    [MonthDayNanoIntervalType](#classarrow_1_1_month_day_nano_interval_type)
    instance.

<!-- -->

std::shared_ptr\<DataType\> timestamp(TimeUnit::type unit)[\#](#_CPPv49timestampN8TimeUnit4typeE)\

:   Create a [TimestampType](#classarrow_1_1_timestamp_type) instance
    from its unit.

<!-- -->

std::shared_ptr\<DataType\> timestamp(TimeUnit::type unit, const std::string &timezone)[\#](#_CPPv49timestampN8TimeUnit4typeERKNSt6stringE)\

:   Create a [TimestampType](#classarrow_1_1_timestamp_type) instance
    from its unit and timezone.

<!-- -->

std::shared_ptr\<DataType\> time32(TimeUnit::type unit)[\#](#_CPPv46time32N8TimeUnit4typeE)\

:   Create a 32-bit time type instance.

    Unit can be either SECOND or MILLI

<!-- -->

std::shared_ptr\<DataType\> time64(TimeUnit::type unit)[\#](#_CPPv46time64N8TimeUnit4typeE)\

:   Create a 64-bit time type instance.

    Unit can be either MICRO or NANO

<!-- -->

std::shared_ptr\<DataType\> struct\_(const FieldVector &fields)[\#](#_CPPv47struct_RK11FieldVector)\

:   Create a [StructType](#classarrow_1_1_struct_type) instance.

<!-- -->

std::shared_ptr\<DataType\> struct\_(std::initializer_list\<std::pair\<std::string, std::shared_ptr\<DataType\>\>\> fields)[\#](#_CPPv47struct_NSt16initializer_listINSt4pairINSt6stringENSt10shared_ptrI8DataTypeEEEEEE)\

:   Create a [StructType](#classarrow_1_1_struct_type) instance from
    (name, type) pairs.

<!-- -->

std::shared_ptr\<DataType\> run_end_encoded(std::shared_ptr\<DataType\> run_end_type, std::shared_ptr\<DataType\> value_type)[\#](#_CPPv415run_end_encodedNSt10shared_ptrI8DataTypeEENSt10shared_ptrI8DataTypeEE)\

:   Create a [RunEndEncodedType](#classarrow_1_1_run_end_encoded_type)
    instance.

<!-- -->

std::shared_ptr\<DataType\> sparse_union(FieldVector child_fields, std::vector\<int8_t\> type_codes = {})[\#](#_CPPv412sparse_union11FieldVectorNSt6vectorI6int8_tEE)\

:   Create a [SparseUnionType](#classarrow_1_1_sparse_union_type)
    instance.

<!-- -->

std::shared_ptr\<DataType\> sparse_union(const ArrayVector &children, std::vector\<std::string\> field_names = {}, std::vector\<int8_t\> type_codes = {})[\#](#_CPPv412sparse_unionRK11ArrayVectorNSt6vectorINSt6stringEEENSt6vectorI6int8_tEE)\

:   Create a [SparseUnionType](#classarrow_1_1_sparse_union_type)
    instance.

<!-- -->

std::shared_ptr\<DataType\> dense_union(FieldVector child_fields, std::vector\<int8_t\> type_codes = {})[\#](#_CPPv411dense_union11FieldVectorNSt6vectorI6int8_tEE)\

:   Create a [DenseUnionType](#classarrow_1_1_dense_union_type)
    instance.

<!-- -->

std::shared_ptr\<DataType\> dense_union(const ArrayVector &children, std::vector\<std::string\> field_names = {}, std::vector\<int8_t\> type_codes = {})[\#](#_CPPv411dense_unionRK11ArrayVectorNSt6vectorINSt6stringEEENSt6vectorI6int8_tEE)\

:   Create a [DenseUnionType](#classarrow_1_1_dense_union_type)
    instance.

<!-- -->

std::shared_ptr\<DataType\> dictionary(const std::shared_ptr\<DataType\> &index_type, const std::shared_ptr\<DataType\> &dict_type, bool ordered = false)[\#](#_CPPv410dictionaryRKNSt10shared_ptrI8DataTypeEERKNSt10shared_ptrI8DataTypeEEb)\

:   Create a [DictionaryType](#classarrow_1_1_dictionary_type) instance.

    Parameters:

    :   -   **index_type** -- **\[in\]** the type of the dictionary
            indices (must be a signed integer)

        -   **dict_type** -- **\[in\]** the type of the values in the
            variable dictionary

        -   **ordered** -- **\[in\]** true if the order of the
            dictionary values has semantic meaning and should be
            preserved where possible
:::

::::::::: section
## Concrete type subclasses[\#](#concrete-type-subclasses)

::: section
### Primitive[\#](#primitive)

class NullType : public arrow::[DataType](#_CPPv4N5arrow8DataTypeE)[\#](#_CPPv4N5arrow8NullTypeE)\

:   Concrete type class for always-null data.

    Public Functions

    virtual std::string ToString(bool show_metadata = false) const override[\#](#_CPPv4NK5arrow8NullType8ToStringEb)\

    :   A string representation of the type, including any children.

    <!-- -->

    inline virtual DataTypeLayout layout() const override[\#](#_CPPv4NK5arrow8NullType6layoutEv)\

    :   Return the data type layout.

        Children are not included.

        Note

        Experimental API

    <!-- -->

    inline virtual std::string name() const override[\#](#_CPPv4NK5arrow8NullType4nameEv)\

    :   A string name of the type, omitting any child fields.

        **Since**

        :   0.7.0

<!-- -->

class BooleanType : public arrow::detail::CTypeImpl\<[BooleanType](#_CPPv4N5arrow11BooleanTypeE), PrimitiveCType, Type::[BOOL](#_CPPv4N5arrow4Type4type4BOOLE), bool\>[\#](#_CPPv4N5arrow11BooleanTypeE)\

:   Concrete type class for boolean data.

    Public Functions

    inline virtual int bit_width() const final[\#](#_CPPv4NK5arrow11BooleanType9bit_widthEv)\

    :   Returns the type's fixed bit width, if any.

        Returns -1 for non-fixed-width types, and should only be used
        for subclasses of FixedWidthType

    <!-- -->

    inline virtual DataTypeLayout layout() const override[\#](#_CPPv4NK5arrow11BooleanType6layoutEv)\

    :   Return the data type layout.

        Children are not included.

        Note

        Experimental API

<!-- -->

class UInt8Type : public arrow::detail::IntegerTypeImpl\<[UInt8Type](#_CPPv4N5arrow9UInt8TypeE), Type::[UINT8](#_CPPv4N5arrow4Type4type5UINT8E), uint8_t\>[\#](#_CPPv4N5arrow9UInt8TypeE)\

:        

    *#include \<arrow/type.h\>*

    Concrete type class for unsigned 8-bit integer data.

<!-- -->

class Int8Type : public arrow::detail::IntegerTypeImpl\<[Int8Type](#_CPPv4N5arrow8Int8TypeE), Type::[INT8](#_CPPv4N5arrow4Type4type4INT8E), int8_t\>[\#](#_CPPv4N5arrow8Int8TypeE)\

:        

    *#include \<arrow/type.h\>*

    Concrete type class for signed 8-bit integer data.

<!-- -->

class UInt16Type : public arrow::detail::IntegerTypeImpl\<[UInt16Type](#_CPPv4N5arrow10UInt16TypeE), Type::[UINT16](#_CPPv4N5arrow4Type4type6UINT16E), uint16_t\>[\#](#_CPPv4N5arrow10UInt16TypeE)\

:        

    *#include \<arrow/type.h\>*

    Concrete type class for unsigned 16-bit integer data.

<!-- -->

class Int16Type : public arrow::detail::IntegerTypeImpl\<[Int16Type](#_CPPv4N5arrow9Int16TypeE), Type::[INT16](#_CPPv4N5arrow4Type4type5INT16E), int16_t\>[\#](#_CPPv4N5arrow9Int16TypeE)\

:        

    *#include \<arrow/type.h\>*

    Concrete type class for signed 16-bit integer data.

<!-- -->

class UInt32Type : public arrow::detail::IntegerTypeImpl\<[UInt32Type](#_CPPv4N5arrow10UInt32TypeE), Type::[UINT32](#_CPPv4N5arrow4Type4type6UINT32E), uint32_t\>[\#](#_CPPv4N5arrow10UInt32TypeE)\

:        

    *#include \<arrow/type.h\>*

    Concrete type class for unsigned 32-bit integer data.

<!-- -->

class Int32Type : public arrow::detail::IntegerTypeImpl\<[Int32Type](#_CPPv4N5arrow9Int32TypeE), Type::[INT32](#_CPPv4N5arrow4Type4type5INT32E), int32_t\>[\#](#_CPPv4N5arrow9Int32TypeE)\

:        

    *#include \<arrow/type.h\>*

    Concrete type class for signed 32-bit integer data.

<!-- -->

class UInt64Type : public arrow::detail::IntegerTypeImpl\<[UInt64Type](#_CPPv4N5arrow10UInt64TypeE), Type::[UINT64](#_CPPv4N5arrow4Type4type6UINT64E), uint64_t\>[\#](#_CPPv4N5arrow10UInt64TypeE)\

:        

    *#include \<arrow/type.h\>*

    Concrete type class for unsigned 64-bit integer data.

<!-- -->

class Int64Type : public arrow::detail::IntegerTypeImpl\<[Int64Type](#_CPPv4N5arrow9Int64TypeE), Type::[INT64](#_CPPv4N5arrow4Type4type5INT64E), int64_t\>[\#](#_CPPv4N5arrow9Int64TypeE)\

:        

    *#include \<arrow/type.h\>*

    Concrete type class for signed 64-bit integer data.

<!-- -->

class HalfFloatType : public arrow::detail::CTypeImpl\<[HalfFloatType](#_CPPv4N5arrow13HalfFloatTypeE), FloatingPointType, Type::[HALF_FLOAT](#_CPPv4N5arrow4Type4type10HALF_FLOATE), uint16_t\>[\#](#_CPPv4N5arrow13HalfFloatTypeE)\

:        

    *#include \<arrow/type.h\>*

    Concrete type class for 16-bit floating-point data.

<!-- -->

class FloatType : public arrow::detail::CTypeImpl\<[FloatType](#_CPPv4N5arrow9FloatTypeE), FloatingPointType, Type::[FLOAT](#_CPPv4N5arrow4Type4type5FLOATE), float\>[\#](#_CPPv4N5arrow9FloatTypeE)\

:        

    *#include \<arrow/type.h\>*

    Concrete type class for 32-bit floating-point data (C "float")

<!-- -->

class DoubleType : public arrow::detail::CTypeImpl\<[DoubleType](#_CPPv4N5arrow10DoubleTypeE), FloatingPointType, Type::[DOUBLE](#_CPPv4N5arrow4Type4type6DOUBLEE), double\>[\#](#_CPPv4N5arrow10DoubleTypeE)\

:        

    *#include \<arrow/type.h\>*

    Concrete type class for 64-bit floating-point data (C "double")

<!-- -->

class DecimalType : public arrow::[FixedSizeBinaryType](#_CPPv4N5arrow19FixedSizeBinaryTypeE)[\#](#_CPPv4N5arrow11DecimalTypeE)\

:        

    *#include \<arrow/type.h\>*

    Base type class for (fixed-size) decimal data.

    Subclassed by
    [arrow::Decimal128Type](#classarrow_1_1_decimal128_type),
    [arrow::Decimal256Type](#classarrow_1_1_decimal256_type),
    [arrow::Decimal32Type](#classarrow_1_1_decimal32_type),
    [arrow::Decimal64Type](#classarrow_1_1_decimal64_type)

    Public Static Functions

    static [Result](support.html#_CPPv4I0EN5arrow6ResultE)\<std::shared_ptr\<[DataType](#_CPPv4N5arrow8DataTypeE)\>\> Make(Type::[type](#_CPPv4N5arrow4Type4typeE) type_id, int32_t precision, int32_t scale)[\#](#_CPPv4N5arrow11DecimalType4MakeEN4Type4typeE7int32_t7int32_t)\

    :   Constructs concrete decimal types.

    <!-- -->

    static int32_t DecimalSize(int32_t precision)[\#](#_CPPv4N5arrow11DecimalType11DecimalSizeE7int32_t)\

    :   Returns the number of bytes needed for precision.

        precision must be \>= 1

<!-- -->

class Decimal32Type : public arrow::[DecimalType](#_CPPv4N5arrow11DecimalTypeE)[\#](#_CPPv4N5arrow13Decimal32TypeE)\

:        

    *#include \<arrow/type.h\>*

    Concrete type class for 32-bit decimal data.

    Arrow decimals are fixed-point decimal numbers encoded as a scaled
    integer. The precision is the number of significant digits that the
    decimal type can represent; the scale is the number of digits after
    the decimal point (note the scale can be negative).

    As an example, `Decimal32Type(7,`` ``3)` can exactly represent the
    numbers 1234.567 and -1234.567 (encoded internally as the 32-bit
    integers 1234567 and -1234567, respectively), but neither 12345.67
    nor 123.4567.

    [Decimal32Type](#classarrow_1_1_decimal32_type) has a maximum
    precision of 9 significant digits (also available as
    Decimal32Type::kMaxPrecision). If higher precision is needed,
    consider using [Decimal64Type](#classarrow_1_1_decimal64_type),
    [Decimal128Type](#classarrow_1_1_decimal128_type) or
    [Decimal256Type](#classarrow_1_1_decimal256_type).

    Public Functions

    explicit Decimal32Type(int32_t precision, int32_t scale)[\#](#_CPPv4N5arrow13Decimal32Type13Decimal32TypeE7int32_t7int32_t)\

    :   [Decimal32Type](#classarrow_1_1_decimal32_type) constructor that
        aborts on invalid input.

    <!-- -->

    virtual std::string ToString(bool show_metadata = false) const override[\#](#_CPPv4NK5arrow13Decimal32Type8ToStringEb)\

    :   A string representation of the type, including any children.

    <!-- -->

    inline virtual std::string name() const override[\#](#_CPPv4NK5arrow13Decimal32Type4nameEv)\

    :   A string name of the type, omitting any child fields.

        **Since**

        :   0.7.0

    Public Static Functions

    static [Result](support.html#_CPPv4I0EN5arrow6ResultE)\<std::shared_ptr\<[DataType](#_CPPv4N5arrow8DataTypeE)\>\> Make(int32_t precision, int32_t scale)[\#](#_CPPv4N5arrow13Decimal32Type4MakeE7int32_t7int32_t)\

    :   [Decimal32Type](#classarrow_1_1_decimal32_type) constructor that
        returns an error on invalid input.

<!-- -->

class Decimal64Type : public arrow::[DecimalType](#_CPPv4N5arrow11DecimalTypeE)[\#](#_CPPv4N5arrow13Decimal64TypeE)\

:        

    *#include \<arrow/type.h\>*

    Concrete type class for 64-bit decimal data.

    Arrow decimals are fixed-point decimal numbers encoded as a scaled
    integer. The precision is the number of significant digits that the
    decimal type can represent; the scale is the number of digits after
    the decimal point (note the scale can be negative).

    As an example, `Decimal64Type(7,`` ``3)` can exactly represent the
    numbers 1234.567 and -1234.567 (encoded internally as the 64-bit
    integers 1234567 and -1234567, respectively), but neither 12345.67
    nor 123.4567.

    [Decimal64Type](#classarrow_1_1_decimal64_type) has a maximum
    precision of 18 significant digits (also available as
    Decimal64Type::kMaxPrecision). If higher precision is needed,
    consider using [Decimal128Type](#classarrow_1_1_decimal128_type) or
    [Decimal256Type](#classarrow_1_1_decimal256_type).

    Public Functions

    explicit Decimal64Type(int32_t precision, int32_t scale)[\#](#_CPPv4N5arrow13Decimal64Type13Decimal64TypeE7int32_t7int32_t)\

    :   [Decimal32Type](#classarrow_1_1_decimal32_type) constructor that
        aborts on invalid input.

    <!-- -->

    virtual std::string ToString(bool show_metadata = false) const override[\#](#_CPPv4NK5arrow13Decimal64Type8ToStringEb)\

    :   A string representation of the type, including any children.

    <!-- -->

    inline virtual std::string name() const override[\#](#_CPPv4NK5arrow13Decimal64Type4nameEv)\

    :   A string name of the type, omitting any child fields.

        **Since**

        :   0.7.0

    Public Static Functions

    static [Result](support.html#_CPPv4I0EN5arrow6ResultE)\<std::shared_ptr\<[DataType](#_CPPv4N5arrow8DataTypeE)\>\> Make(int32_t precision, int32_t scale)[\#](#_CPPv4N5arrow13Decimal64Type4MakeE7int32_t7int32_t)\

    :   [Decimal32Type](#classarrow_1_1_decimal32_type) constructor that
        returns an error on invalid input.

<!-- -->

class Decimal128Type : public arrow::[DecimalType](#_CPPv4N5arrow11DecimalTypeE)[\#](#_CPPv4N5arrow14Decimal128TypeE)\

:        

    *#include \<arrow/type.h\>*

    Concrete type class for 128-bit decimal data.

    Arrow decimals are fixed-point decimal numbers encoded as a scaled
    integer. The precision is the number of significant digits that the
    decimal type can represent; the scale is the number of digits after
    the decimal point (note the scale can be negative).

    As an example, `Decimal128Type(7,`` ``3)` can exactly represent the
    numbers 1234.567 and -1234.567 (encoded internally as the 128-bit
    integers 1234567 and -1234567, respectively), but neither 12345.67
    nor 123.4567.

    [Decimal128Type](#classarrow_1_1_decimal128_type) has a maximum
    precision of 38 significant digits (also available as
    Decimal128Type::kMaxPrecision). If higher precision is needed,
    consider using [Decimal256Type](#classarrow_1_1_decimal256_type).

    Public Functions

    explicit Decimal128Type(int32_t precision, int32_t scale)[\#](#_CPPv4N5arrow14Decimal128Type14Decimal128TypeE7int32_t7int32_t)\

    :   [Decimal128Type](#classarrow_1_1_decimal128_type) constructor
        that aborts on invalid input.

    <!-- -->

    virtual std::string ToString(bool show_metadata = false) const override[\#](#_CPPv4NK5arrow14Decimal128Type8ToStringEb)\

    :   A string representation of the type, including any children.

    <!-- -->

    inline virtual std::string name() const override[\#](#_CPPv4NK5arrow14Decimal128Type4nameEv)\

    :   A string name of the type, omitting any child fields.

        **Since**

        :   0.7.0

    Public Static Functions

    static [Result](support.html#_CPPv4I0EN5arrow6ResultE)\<std::shared_ptr\<[DataType](#_CPPv4N5arrow8DataTypeE)\>\> Make(int32_t precision, int32_t scale)[\#](#_CPPv4N5arrow14Decimal128Type4MakeE7int32_t7int32_t)\

    :   [Decimal128Type](#classarrow_1_1_decimal128_type) constructor
        that returns an error on invalid input.

<!-- -->

class Decimal256Type : public arrow::[DecimalType](#_CPPv4N5arrow11DecimalTypeE)[\#](#_CPPv4N5arrow14Decimal256TypeE)\

:        

    *#include \<arrow/type.h\>*

    Concrete type class for 256-bit decimal data.

    Arrow decimals are fixed-point decimal numbers encoded as a scaled
    integer. The precision is the number of significant digits that the
    decimal type can represent; the scale is the number of digits after
    the decimal point (note the scale can be negative).

    [Decimal256Type](#classarrow_1_1_decimal256_type) has a maximum
    precision of 76 significant digits. (also available as
    Decimal256Type::kMaxPrecision).

    For most use cases, the maximum precision offered by
    [Decimal128Type](#classarrow_1_1_decimal128_type) is sufficient, and
    it will result in a more compact and more efficient encoding.

    Public Functions

    explicit Decimal256Type(int32_t precision, int32_t scale)[\#](#_CPPv4N5arrow14Decimal256Type14Decimal256TypeE7int32_t7int32_t)\

    :   [Decimal256Type](#classarrow_1_1_decimal256_type) constructor
        that aborts on invalid input.

    <!-- -->

    virtual std::string ToString(bool show_metadata = false) const override[\#](#_CPPv4NK5arrow14Decimal256Type8ToStringEb)\

    :   A string representation of the type, including any children.

    <!-- -->

    inline virtual std::string name() const override[\#](#_CPPv4NK5arrow14Decimal256Type4nameEv)\

    :   A string name of the type, omitting any child fields.

        **Since**

        :   0.7.0

    Public Static Functions

    static [Result](support.html#_CPPv4I0EN5arrow6ResultE)\<std::shared_ptr\<[DataType](#_CPPv4N5arrow8DataTypeE)\>\> Make(int32_t precision, int32_t scale)[\#](#_CPPv4N5arrow14Decimal256Type4MakeE7int32_t7int32_t)\

    :   [Decimal256Type](#classarrow_1_1_decimal256_type) constructor
        that returns an error on invalid input.

:::

::: section
### Temporal[\#](#temporal)

enum arrow::TimeUnit::type[\#](#_CPPv4N5arrow8TimeUnit4typeE)\

:   The unit for a time or timestamp
    [DataType](#classarrow_1_1_data_type).

    *Values:*

    enumerator SECOND[\#](#_CPPv4N5arrow8TimeUnit4type6SECONDE)\

    :   

    enumerator MILLI[\#](#_CPPv4N5arrow8TimeUnit4type5MILLIE)\

    :   

    enumerator MICRO[\#](#_CPPv4N5arrow8TimeUnit4type5MICROE)\

    :   

    enumerator NANO[\#](#_CPPv4N5arrow8TimeUnit4type4NANOE)\

    :   

<!-- -->

std::ostream &operator\<\<(std::ostream &os, TimeUnit::type unit)[\#](#_CPPv4lsRNSt7ostreamEN8TimeUnit4typeE)\

:   

<!-- -->

std::ostream &operator\<\<(std::ostream &os, DayTimeIntervalType::DayMilliseconds interval)[\#](#_CPPv4lsRNSt7ostreamEN19DayTimeIntervalType15DayMillisecondsE)\

:   

<!-- -->

std::ostream &operator\<\<(std::ostream &os, MonthDayNanoIntervalType::MonthDayNanos interval)[\#](#_CPPv4lsRNSt7ostreamEN24MonthDayNanoIntervalType13MonthDayNanosE)\

:   

<!-- -->

class TemporalType : public arrow::FixedWidthType[\#](#_CPPv4N5arrow12TemporalTypeE)\

:        

    *#include \<arrow/type.h\>*

    Base type for all date and time types.

    Subclassed by [arrow::DateType](#classarrow_1_1_date_type),
    [arrow::DurationType](#classarrow_1_1_duration_type),
    [arrow::IntervalType](#classarrow_1_1_interval_type),
    [arrow::TimeType](#classarrow_1_1_time_type),
    [arrow::TimestampType](#classarrow_1_1_timestamp_type)

    Public Functions

    inline virtual DataTypeLayout layout() const override[\#](#_CPPv4NK5arrow12TemporalType6layoutEv)\

    :   Return the data type layout.

        Children are not included.

        Note

        Experimental API

<!-- -->

class DateType : public arrow::[TemporalType](#_CPPv4N5arrow12TemporalTypeE)[\#](#_CPPv4N5arrow8DateTypeE)\

:        

    *#include \<arrow/type.h\>*

    Base type class for date data.

    Subclassed by [arrow::Date32Type](#classarrow_1_1_date32_type),
    [arrow::Date64Type](#classarrow_1_1_date64_type)

<!-- -->

class Date32Type : public arrow::[DateType](#_CPPv4N5arrow8DateTypeE)[\#](#_CPPv4N5arrow10Date32TypeE)\

:        

    *#include \<arrow/type.h\>*

    Concrete type class for 32-bit date data (as number of days since
    UNIX epoch)

    Public Functions

    inline virtual int bit_width() const override[\#](#_CPPv4NK5arrow10Date32Type9bit_widthEv)\

    :   Returns the type's fixed bit width, if any.

        Returns -1 for non-fixed-width types, and should only be used
        for subclasses of FixedWidthType

    <!-- -->

    virtual std::string ToString(bool show_metadata = false) const override[\#](#_CPPv4NK5arrow10Date32Type8ToStringEb)\

    :   A string representation of the type, including any children.

    <!-- -->

    inline virtual std::string name() const override[\#](#_CPPv4NK5arrow10Date32Type4nameEv)\

    :   A string name of the type, omitting any child fields.

        **Since**

        :   0.7.0

<!-- -->

class Date64Type : public arrow::[DateType](#_CPPv4N5arrow8DateTypeE)[\#](#_CPPv4N5arrow10Date64TypeE)\

:        

    *#include \<arrow/type.h\>*

    Concrete type class for 64-bit date data (as number of milliseconds
    since UNIX epoch)

    Public Functions

    inline virtual int bit_width() const override[\#](#_CPPv4NK5arrow10Date64Type9bit_widthEv)\

    :   Returns the type's fixed bit width, if any.

        Returns -1 for non-fixed-width types, and should only be used
        for subclasses of FixedWidthType

    <!-- -->

    virtual std::string ToString(bool show_metadata = false) const override[\#](#_CPPv4NK5arrow10Date64Type8ToStringEb)\

    :   A string representation of the type, including any children.

    <!-- -->

    inline virtual std::string name() const override[\#](#_CPPv4NK5arrow10Date64Type4nameEv)\

    :   A string name of the type, omitting any child fields.

        **Since**

        :   0.7.0

<!-- -->

class TimeType : public arrow::[TemporalType](#_CPPv4N5arrow12TemporalTypeE), public arrow::ParametricType[\#](#_CPPv4N5arrow8TimeTypeE)\

:        

    *#include \<arrow/type.h\>*

    Base type class for time data.

    Subclassed by [arrow::Time32Type](#classarrow_1_1_time32_type),
    [arrow::Time64Type](#classarrow_1_1_time64_type)

<!-- -->

class Time32Type : public arrow::[TimeType](#_CPPv4N5arrow8TimeTypeE)[\#](#_CPPv4N5arrow10Time32TypeE)\

:        

    *#include \<arrow/type.h\>*

    Concrete type class for 32-bit time data (as number of seconds or
    milliseconds since midnight)

    Public Functions

    inline virtual int bit_width() const override[\#](#_CPPv4NK5arrow10Time32Type9bit_widthEv)\

    :   Returns the type's fixed bit width, if any.

        Returns -1 for non-fixed-width types, and should only be used
        for subclasses of FixedWidthType

    <!-- -->

    virtual std::string ToString(bool show_metadata = false) const override[\#](#_CPPv4NK5arrow10Time32Type8ToStringEb)\

    :   A string representation of the type, including any children.

    <!-- -->

    inline virtual std::string name() const override[\#](#_CPPv4NK5arrow10Time32Type4nameEv)\

    :   A string name of the type, omitting any child fields.

        **Since**

        :   0.7.0

<!-- -->

class Time64Type : public arrow::[TimeType](#_CPPv4N5arrow8TimeTypeE)[\#](#_CPPv4N5arrow10Time64TypeE)\

:        

    *#include \<arrow/type.h\>*

    Concrete type class for 64-bit time data (as number of microseconds
    or nanoseconds since midnight)

    Public Functions

    inline virtual int bit_width() const override[\#](#_CPPv4NK5arrow10Time64Type9bit_widthEv)\

    :   Returns the type's fixed bit width, if any.

        Returns -1 for non-fixed-width types, and should only be used
        for subclasses of FixedWidthType

    <!-- -->

    virtual std::string ToString(bool show_metadata = false) const override[\#](#_CPPv4NK5arrow10Time64Type8ToStringEb)\

    :   A string representation of the type, including any children.

    <!-- -->

    inline virtual std::string name() const override[\#](#_CPPv4NK5arrow10Time64Type4nameEv)\

    :   A string name of the type, omitting any child fields.

        **Since**

        :   0.7.0

<!-- -->

class TimestampType : public arrow::[TemporalType](#_CPPv4N5arrow12TemporalTypeE), public arrow::ParametricType[\#](#_CPPv4N5arrow13TimestampTypeE)\

:        

    *#include \<arrow/type.h\>*

    Concrete type class for datetime data (as number of seconds,
    milliseconds, microseconds or nanoseconds since UNIX epoch)

    If supplied, the timezone string should take either the form (i)
    "Area/Location", with values drawn from the names in the IANA Time
    Zone Database (such as "Europe/Zurich"); or (ii) "(+\|-)HH:MM"
    indicating an absolute offset from GMT (such as "-08:00"). To
    indicate a native UTC timestamp, one of the strings "UTC", "Etc/UTC"
    or "+00:00" should be used.

    If any non-empty string is supplied as the timezone for a
    [TimestampType](#classarrow_1_1_timestamp_type), then the Arrow
    field containing that timestamp type (and by extension the column
    associated with such a field) is considered "timezone-aware". The
    integer arrays that comprise a timezone-aware column must contain
    UTC normalized datetime values, regardless of the contents of their
    timezone string. More precisely, (i) the producer of a
    timezone-aware column must populate its constituent arrays with
    valid UTC values (performing offset conversions from non-UTC values
    if necessary); and (ii) the consumer of a timezone-aware column may
    assume that the column's values are directly comparable (that is,
    with no offset adjustment required) to the values of any other
    timezone-aware column or to any other valid UTC datetime value
    (provided all values are expressed in the same units).

    If a [TimestampType](#classarrow_1_1_timestamp_type) is constructed
    without a timezone (or, equivalently, if the timezone supplied is an
    empty string) then the resulting Arrow field (column) is considered
    "timezone-naive". The producer of a timezone-naive column may
    populate its constituent integer arrays with datetime values from
    any timezone; the consumer of a timezone-naive column should make no
    assumptions about the interoperability or comparability of the
    values of such a column with those of any other timestamp column or
    datetime value.

    If a timezone-aware field contains a recognized timezone, its values
    may be localized to that locale upon display; the values of
    timezone-naive fields must always be displayed "as is", with no
    localization performed on them.

    Public Functions

    inline virtual int bit_width() const override[\#](#_CPPv4NK5arrow13TimestampType9bit_widthEv)\

    :   Returns the type's fixed bit width, if any.

        Returns -1 for non-fixed-width types, and should only be used
        for subclasses of FixedWidthType

    <!-- -->

    virtual std::string ToString(bool show_metadata = false) const override[\#](#_CPPv4NK5arrow13TimestampType8ToStringEb)\

    :   A string representation of the type, including any children.

    <!-- -->

    inline virtual std::string name() const override[\#](#_CPPv4NK5arrow13TimestampType4nameEv)\

    :   A string name of the type, omitting any child fields.

        **Since**

        :   0.7.0

<!-- -->

class IntervalType : public arrow::[TemporalType](#_CPPv4N5arrow12TemporalTypeE), public arrow::ParametricType[\#](#_CPPv4N5arrow12IntervalTypeE)\

:        

    *#include \<arrow/type.h\>*

    Subclassed by
    [arrow::DayTimeIntervalType](#classarrow_1_1_day_time_interval_type),
    [arrow::MonthDayNanoIntervalType](#classarrow_1_1_month_day_nano_interval_type),
    [arrow::MonthIntervalType](#classarrow_1_1_month_interval_type)

<!-- -->

class MonthIntervalType : public arrow::[IntervalType](#_CPPv4N5arrow12IntervalTypeE)[\#](#_CPPv4N5arrow17MonthIntervalTypeE)\

:        

    *#include \<arrow/type.h\>*

    Represents a number of months.

    Type representing a number of months. Corresponds to YearMonth type
    in Schema.fbs (years are defined as 12 months).

    Public Functions

    inline virtual int bit_width() const override[\#](#_CPPv4NK5arrow17MonthIntervalType9bit_widthEv)\

    :   Returns the type's fixed bit width, if any.

        Returns -1 for non-fixed-width types, and should only be used
        for subclasses of FixedWidthType

    <!-- -->

    inline virtual std::string ToString(bool show_metadata = false) const override[\#](#_CPPv4NK5arrow17MonthIntervalType8ToStringEb)\

    :   A string representation of the type, including any children.

    <!-- -->

    inline virtual std::string name() const override[\#](#_CPPv4NK5arrow17MonthIntervalType4nameEv)\

    :   A string name of the type, omitting any child fields.

        **Since**

        :   0.7.0

<!-- -->

class DayTimeIntervalType : public arrow::[IntervalType](#_CPPv4N5arrow12IntervalTypeE)[\#](#_CPPv4N5arrow19DayTimeIntervalTypeE)\

:        

    *#include \<arrow/type.h\>*

    Represents a number of days and milliseconds (fraction of day).

    Public Functions

    inline virtual int bit_width() const override[\#](#_CPPv4NK5arrow19DayTimeIntervalType9bit_widthEv)\

    :   Returns the type's fixed bit width, if any.

        Returns -1 for non-fixed-width types, and should only be used
        for subclasses of FixedWidthType

    <!-- -->

    inline virtual std::string ToString(bool show_metadata = false) const override[\#](#_CPPv4NK5arrow19DayTimeIntervalType8ToStringEb)\

    :   A string representation of the type, including any children.

    <!-- -->

    inline virtual std::string name() const override[\#](#_CPPv4NK5arrow19DayTimeIntervalType4nameEv)\

    :   A string name of the type, omitting any child fields.

        **Since**

        :   0.7.0

    struct DayMilliseconds[\#](#_CPPv4N5arrow19DayTimeIntervalType15DayMillisecondsE)\

    :        

        *#include \<arrow/type.h\>*

<!-- -->

class MonthDayNanoIntervalType : public arrow::[IntervalType](#_CPPv4N5arrow12IntervalTypeE)[\#](#_CPPv4N5arrow24MonthDayNanoIntervalTypeE)\

:        

    *#include \<arrow/type.h\>*

    Represents a number of months, days and nanoseconds between two
    dates.

    All fields are independent from one another.

    Public Functions

    inline virtual int bit_width() const override[\#](#_CPPv4NK5arrow24MonthDayNanoIntervalType9bit_widthEv)\

    :   Returns the type's fixed bit width, if any.

        Returns -1 for non-fixed-width types, and should only be used
        for subclasses of FixedWidthType

    <!-- -->

    inline virtual std::string ToString(bool show_metadata = false) const override[\#](#_CPPv4NK5arrow24MonthDayNanoIntervalType8ToStringEb)\

    :   A string representation of the type, including any children.

    <!-- -->

    inline virtual std::string name() const override[\#](#_CPPv4NK5arrow24MonthDayNanoIntervalType4nameEv)\

    :   A string name of the type, omitting any child fields.

        **Since**

        :   0.7.0

    struct MonthDayNanos[\#](#_CPPv4N5arrow24MonthDayNanoIntervalType13MonthDayNanosE)\

    :        

        *#include \<arrow/type.h\>*

<!-- -->

class DurationType : public arrow::[TemporalType](#_CPPv4N5arrow12TemporalTypeE), public arrow::ParametricType[\#](#_CPPv4N5arrow12DurationTypeE)\

:        

    *#include \<arrow/type.h\>*

    Represents an elapsed time without any relation to a calendar
    artifact.

    Public Functions

    inline virtual int bit_width() const override[\#](#_CPPv4NK5arrow12DurationType9bit_widthEv)\

    :   Returns the type's fixed bit width, if any.

        Returns -1 for non-fixed-width types, and should only be used
        for subclasses of FixedWidthType

    <!-- -->

    virtual std::string ToString(bool show_metadata = false) const override[\#](#_CPPv4NK5arrow12DurationType8ToStringEb)\

    :   A string representation of the type, including any children.

    <!-- -->

    inline virtual std::string name() const override[\#](#_CPPv4NK5arrow12DurationType4nameEv)\

    :   A string name of the type, omitting any child fields.

        **Since**

        :   0.7.0

:::

::: section
### Binary-like[\#](#binary-like)

class BinaryType : public arrow::BaseBinaryType[\#](#_CPPv4N5arrow10BinaryTypeE)\

:        

    *#include \<arrow/type.h\>*

    Concrete type class for variable-size binary data.

    Subclassed by [arrow::StringType](#classarrow_1_1_string_type)

    Public Functions

    inline virtual DataTypeLayout layout() const override[\#](#_CPPv4NK5arrow10BinaryType6layoutEv)\

    :   Return the data type layout.

        Children are not included.

        Note

        Experimental API

    <!-- -->

    virtual std::string ToString(bool show_metadata = false) const override[\#](#_CPPv4NK5arrow10BinaryType8ToStringEb)\

    :   A string representation of the type, including any children.

    <!-- -->

    inline virtual std::string name() const override[\#](#_CPPv4NK5arrow10BinaryType4nameEv)\

    :   A string name of the type, omitting any child fields.

        **Since**

        :   0.7.0

<!-- -->

class BinaryViewType : public arrow::[DataType](#_CPPv4N5arrow8DataTypeE)[\#](#_CPPv4N5arrow14BinaryViewTypeE)\

:        

    *#include \<arrow/type.h\>*

    Concrete type class for variable-size binary view data.

    Subclassed by
    [arrow::StringViewType](#classarrow_1_1_string_view_type)

    Public Functions

    inline virtual DataTypeLayout layout() const override[\#](#_CPPv4NK5arrow14BinaryViewType6layoutEv)\

    :   Return the data type layout.

        Children are not included.

        Note

        Experimental API

    <!-- -->

    virtual std::string ToString(bool show_metadata = false) const override[\#](#_CPPv4NK5arrow14BinaryViewType8ToStringEb)\

    :   A string representation of the type, including any children.

    <!-- -->

    inline virtual std::string name() const override[\#](#_CPPv4NK5arrow14BinaryViewType4nameEv)\

    :   A string name of the type, omitting any child fields.

        **Since**

        :   0.7.0

    union c_type[\#](#_CPPv4N5arrow14BinaryViewType6c_typeE)\

    :        

        *#include \<arrow/type.h\>*

        Variable length string or binary with inline optimization for
        small values (12 bytes or fewer).

        This is similar to std::string_view except limited in size to
        INT32_MAX and at least the first four bytes of the string are
        copied inline (accessible without pointer dereference). This
        inline prefix allows failing comparisons early. Furthermore when
        dealing with short strings the CPU cache working set is reduced
        since many can be inline.

        This union supports two states:

        -   Entirely inlined string data

                  |----|--------------|
                   ^    ^
                   |    |
                size    in-line string data, zero padded

        -   Reference into a buffer

                  |----|----|----|----|
                   ^    ^    ^    ^
                   |    |    |    |
                size    |    |    `------.
                    prefix   |           |
                          buffer index   |
                                    offset in buffer

        Adapted from TU Munich's UmbraDB
        [1](https://db.in.tum.de/~freitag/papers/p29-neumann-cidr20.pdf),
        Velox, DuckDB.

        Alignment to 64 bits enables an aligned load of the size and
        prefix into a single 64 bit integer, which is useful to the
        comparison fast path.

        Public Functions

        inline int32_t size() const\

        :   The number of bytes viewed.

        <!-- -->

        inline bool is_inline() const[\#](#_CPPv4NK5arrow14BinaryViewType6c_type9is_inlineEv)\

        :   True if the view's data is entirely stored inline.

        <!-- -->

        inline const uint8_t \*inline_data() const &[\#](#_CPPv4NKR5arrow14BinaryViewType6c_type11inline_dataEv)\

        :   Return a pointer to the inline data of a view.

            For inline views, this points to the entire data of the
            view. For other views, this points to the 4 byte prefix.

        <!-- -->

        const uint8_t \*inline_data() && = delete[\#](#_CPPv4NO5arrow14BinaryViewType6c_type11inline_dataEv)\

        :   

        Public Members

        int32_t size[\#](#_CPPv4N5arrow14BinaryViewType6c_type4sizeE)\

        :   

        <!-- -->

        std::array\<uint8_t, kInlineSize\> data[\#](#_CPPv4N5arrow14BinaryViewType6c_type4dataE)\

        :   

        <!-- -->

        struct arrow::[BinaryViewType](#_CPPv4N5arrow14BinaryViewTypeE)::[c_type](#_CPPv4N5arrow14BinaryViewType6c_typeE)::\[anonymous\] inlined[\#](#_CPPv4N5arrow14BinaryViewType6c_type7inlinedE)\

        :   

        <!-- -->

        std::array\<uint8_t, kPrefixSize\> prefix[\#](#_CPPv4N5arrow14BinaryViewType6c_type6prefixE)\

        :   

        <!-- -->

        int32_t buffer_index[\#](#_CPPv4N5arrow14BinaryViewType6c_type12buffer_indexE)\

        :   

        <!-- -->

        int32_t offset[\#](#_CPPv4N5arrow14BinaryViewType6c_type6offsetE)\

        :   

        <!-- -->

        struct arrow::[BinaryViewType](#_CPPv4N5arrow14BinaryViewTypeE)::[c_type](#_CPPv4N5arrow14BinaryViewType6c_typeE)::\[anonymous\] ref[\#](#_CPPv4N5arrow14BinaryViewType6c_type3refE)\

        :   

<!-- -->

class LargeBinaryType : public arrow::BaseBinaryType[\#](#_CPPv4N5arrow15LargeBinaryTypeE)\

:        

    *#include \<arrow/type.h\>*

    Concrete type class for large variable-size binary data.

    Subclassed by
    [arrow::LargeStringType](#classarrow_1_1_large_string_type)

    Public Functions

    inline virtual DataTypeLayout layout() const override[\#](#_CPPv4NK5arrow15LargeBinaryType6layoutEv)\

    :   Return the data type layout.

        Children are not included.

        Note

        Experimental API

    <!-- -->

    virtual std::string ToString(bool show_metadata = false) const override[\#](#_CPPv4NK5arrow15LargeBinaryType8ToStringEb)\

    :   A string representation of the type, including any children.

    <!-- -->

    inline virtual std::string name() const override[\#](#_CPPv4NK5arrow15LargeBinaryType4nameEv)\

    :   A string name of the type, omitting any child fields.

        **Since**

        :   0.7.0

<!-- -->

class StringType : public arrow::[BinaryType](#_CPPv4N5arrow10BinaryTypeE)[\#](#_CPPv4N5arrow10StringTypeE)\

:        

    *#include \<arrow/type.h\>*

    Concrete type class for variable-size string data, utf8-encoded.

    Public Functions

    virtual std::string ToString(bool show_metadata = false) const override[\#](#_CPPv4NK5arrow10StringType8ToStringEb)\

    :   A string representation of the type, including any children.

    <!-- -->

    inline virtual std::string name() const override[\#](#_CPPv4NK5arrow10StringType4nameEv)\

    :   A string name of the type, omitting any child fields.

        **Since**

        :   0.7.0

<!-- -->

class StringViewType : public arrow::[BinaryViewType](#_CPPv4N5arrow14BinaryViewTypeE)[\#](#_CPPv4N5arrow14StringViewTypeE)\

:        

    *#include \<arrow/type.h\>*

    Concrete type class for variable-size string data, utf8-encoded.

    Public Functions

    virtual std::string ToString(bool show_metadata = false) const override[\#](#_CPPv4NK5arrow14StringViewType8ToStringEb)\

    :   A string representation of the type, including any children.

    <!-- -->

    inline virtual std::string name() const override[\#](#_CPPv4NK5arrow14StringViewType4nameEv)\

    :   A string name of the type, omitting any child fields.

        **Since**

        :   0.7.0

<!-- -->

class LargeStringType : public arrow::[LargeBinaryType](#_CPPv4N5arrow15LargeBinaryTypeE)[\#](#_CPPv4N5arrow15LargeStringTypeE)\

:        

    *#include \<arrow/type.h\>*

    Concrete type class for large variable-size string data,
    utf8-encoded.

    Public Functions

    virtual std::string ToString(bool show_metadata = false) const override[\#](#_CPPv4NK5arrow15LargeStringType8ToStringEb)\

    :   A string representation of the type, including any children.

    <!-- -->

    inline virtual std::string name() const override[\#](#_CPPv4NK5arrow15LargeStringType4nameEv)\

    :   A string name of the type, omitting any child fields.

        **Since**

        :   0.7.0

<!-- -->

class FixedSizeBinaryType : public arrow::FixedWidthType, public arrow::ParametricType[\#](#_CPPv4N5arrow19FixedSizeBinaryTypeE)\

:        

    *#include \<arrow/type.h\>*

    Concrete type class for fixed-size binary data.

    Subclassed by [arrow::DecimalType](#classarrow_1_1_decimal_type)

    Public Functions

    virtual std::string ToString(bool show_metadata = false) const override[\#](#_CPPv4NK5arrow19FixedSizeBinaryType8ToStringEb)\

    :   A string representation of the type, including any children.

    <!-- -->

    inline virtual std::string name() const override[\#](#_CPPv4NK5arrow19FixedSizeBinaryType4nameEv)\

    :   A string name of the type, omitting any child fields.

        **Since**

        :   0.7.0

    <!-- -->

    inline virtual DataTypeLayout layout() const override[\#](#_CPPv4NK5arrow19FixedSizeBinaryType6layoutEv)\

    :   Return the data type layout.

        Children are not included.

        Note

        Experimental API

    <!-- -->

    inline virtual int byte_width() const override[\#](#_CPPv4NK5arrow19FixedSizeBinaryType10byte_widthEv)\

    :   Returns the type's fixed byte width, if any.

        Returns -1 for non-fixed-width types, and should only be used
        for subclasses of FixedWidthType

    <!-- -->

    virtual int bit_width() const override[\#](#_CPPv4NK5arrow19FixedSizeBinaryType9bit_widthEv)\

    :   Returns the type's fixed bit width, if any.

        Returns -1 for non-fixed-width types, and should only be used
        for subclasses of FixedWidthType

:::

::: section
### Nested[\#](#nested)

class BaseListType : public arrow::NestedType[\#](#_CPPv4N5arrow12BaseListTypeE)\

:        

    *#include \<arrow/type.h\>*

    Base class for all variable-size list data types.

    Subclassed by
    [arrow::FixedSizeListType](#classarrow_1_1_fixed_size_list_type),
    [arrow::LargeListType](#classarrow_1_1_large_list_type),
    [arrow::LargeListViewType](#classarrow_1_1_large_list_view_type),
    [arrow::ListType](#classarrow_1_1_list_type),
    [arrow::ListViewType](#classarrow_1_1_list_view_type)

<!-- -->

class ListType : public arrow::[BaseListType](#_CPPv4N5arrow12BaseListTypeE)[\#](#_CPPv4N5arrow8ListTypeE)\

:        

    *#include \<arrow/type.h\>*

    Concrete type class for list data.

    List data is nested data where each value is a variable number of
    child items. Lists can be recursively nested, for example
    list(list(int32)).

    Subclassed by [arrow::MapType](#classarrow_1_1_map_type)

    Public Functions

    inline virtual DataTypeLayout layout() const override[\#](#_CPPv4NK5arrow8ListType6layoutEv)\

    :   Return the data type layout.

        Children are not included.

        Note

        Experimental API

    <!-- -->

    virtual std::string ToString(bool show_metadata = false) const override[\#](#_CPPv4NK5arrow8ListType8ToStringEb)\

    :   A string representation of the type, including any children.

    <!-- -->

    inline virtual std::string name() const override[\#](#_CPPv4NK5arrow8ListType4nameEv)\

    :   A string name of the type, omitting any child fields.

        **Since**

        :   0.7.0

<!-- -->

class LargeListType : public arrow::[BaseListType](#_CPPv4N5arrow12BaseListTypeE)[\#](#_CPPv4N5arrow13LargeListTypeE)\

:        

    *#include \<arrow/type.h\>*

    Concrete type class for large list data.

    [LargeListType](#classarrow_1_1_large_list_type) is like
    [ListType](#classarrow_1_1_list_type) but with 64-bit rather than
    32-bit offsets.

    Public Functions

    inline virtual DataTypeLayout layout() const override[\#](#_CPPv4NK5arrow13LargeListType6layoutEv)\

    :   Return the data type layout.

        Children are not included.

        Note

        Experimental API

    <!-- -->

    virtual std::string ToString(bool show_metadata = false) const override[\#](#_CPPv4NK5arrow13LargeListType8ToStringEb)\

    :   A string representation of the type, including any children.

    <!-- -->

    inline virtual std::string name() const override[\#](#_CPPv4NK5arrow13LargeListType4nameEv)\

    :   A string name of the type, omitting any child fields.

        **Since**

        :   0.7.0

<!-- -->

class ListViewType : public arrow::[BaseListType](#_CPPv4N5arrow12BaseListTypeE)[\#](#_CPPv4N5arrow12ListViewTypeE)\

:        

    *#include \<arrow/type.h\>*

    Type class for array of list views.

    Public Functions

    inline virtual DataTypeLayout layout() const override[\#](#_CPPv4NK5arrow12ListViewType6layoutEv)\

    :   Return the data type layout.

        Children are not included.

        Note

        Experimental API

    <!-- -->

    virtual std::string ToString(bool show_metadata = false) const override[\#](#_CPPv4NK5arrow12ListViewType8ToStringEb)\

    :   A string representation of the type, including any children.

    <!-- -->

    inline virtual std::string name() const override[\#](#_CPPv4NK5arrow12ListViewType4nameEv)\

    :   A string name of the type, omitting any child fields.

        **Since**

        :   0.7.0

<!-- -->

class LargeListViewType : public arrow::[BaseListType](#_CPPv4N5arrow12BaseListTypeE)[\#](#_CPPv4N5arrow17LargeListViewTypeE)\

:        

    *#include \<arrow/type.h\>*

    Concrete type class for large list-view data.

    [LargeListViewType](#classarrow_1_1_large_list_view_type) is like
    [ListViewType](#classarrow_1_1_list_view_type) but with 64-bit
    rather than 32-bit offsets and sizes.

    Public Functions

    inline virtual DataTypeLayout layout() const override[\#](#_CPPv4NK5arrow17LargeListViewType6layoutEv)\

    :   Return the data type layout.

        Children are not included.

        Note

        Experimental API

    <!-- -->

    virtual std::string ToString(bool show_metadata = false) const override[\#](#_CPPv4NK5arrow17LargeListViewType8ToStringEb)\

    :   A string representation of the type, including any children.

    <!-- -->

    inline virtual std::string name() const override[\#](#_CPPv4NK5arrow17LargeListViewType4nameEv)\

    :   A string name of the type, omitting any child fields.

        **Since**

        :   0.7.0

<!-- -->

class MapType : public arrow::[ListType](#_CPPv4N5arrow8ListTypeE)[\#](#_CPPv4N5arrow7MapTypeE)\

:        

    *#include \<arrow/type.h\>*

    Concrete type class for map data.

    Map data is nested data where each value is a variable number of
    key-item pairs. Its physical representation is the same as a list of
    `{key,`` ``item}` structs.

    Maps can be recursively nested, for example map(utf8, map(utf8,
    int32)).

    Public Functions

    virtual std::string ToString(bool show_metadata = false) const override[\#](#_CPPv4NK5arrow7MapType8ToStringEb)\

    :   A string representation of the type, including any children.

    <!-- -->

    inline virtual std::string name() const override[\#](#_CPPv4NK5arrow7MapType4nameEv)\

    :   A string name of the type, omitting any child fields.

        **Since**

        :   0.7.0

<!-- -->

class FixedSizeListType : public arrow::[BaseListType](#_CPPv4N5arrow12BaseListTypeE)[\#](#_CPPv4N5arrow17FixedSizeListTypeE)\

:        

    *#include \<arrow/type.h\>*

    Concrete type class for fixed size list data.

    Public Functions

    inline virtual DataTypeLayout layout() const override[\#](#_CPPv4NK5arrow17FixedSizeListType6layoutEv)\

    :   Return the data type layout.

        Children are not included.

        Note

        Experimental API

    <!-- -->

    virtual std::string ToString(bool show_metadata = false) const override[\#](#_CPPv4NK5arrow17FixedSizeListType8ToStringEb)\

    :   A string representation of the type, including any children.

    <!-- -->

    inline virtual std::string name() const override[\#](#_CPPv4NK5arrow17FixedSizeListType4nameEv)\

    :   A string name of the type, omitting any child fields.

        **Since**

        :   0.7.0

<!-- -->

class StructType : public arrow::NestedType[\#](#_CPPv4N5arrow10StructTypeE)\

:        

    *#include \<arrow/type.h\>*

    Concrete type class for struct data.

    Public Functions

    inline virtual DataTypeLayout layout() const override[\#](#_CPPv4NK5arrow10StructType6layoutEv)\

    :   Return the data type layout.

        Children are not included.

        Note

        Experimental API

    <!-- -->

    virtual std::string ToString(bool show_metadata = false) const override[\#](#_CPPv4NK5arrow10StructType8ToStringEb)\

    :   A string representation of the type, including any children.

    <!-- -->

    inline virtual std::string name() const override[\#](#_CPPv4NK5arrow10StructType4nameEv)\

    :   A string name of the type, omitting any child fields.

        **Since**

        :   0.7.0

    <!-- -->

    std::shared_ptr\<[Field](#_CPPv4N5arrow5FieldE)\> GetFieldByName(const std::string &name) const[\#](#_CPPv4NK5arrow10StructType14GetFieldByNameERKNSt6stringE)\

    :   Returns null if name not found.

    <!-- -->

    FieldVector GetAllFieldsByName(const std::string &name) const[\#](#_CPPv4NK5arrow10StructType18GetAllFieldsByNameERKNSt6stringE)\

    :   Return all fields having this name.

    <!-- -->

    int GetFieldIndex(const std::string &name) const[\#](#_CPPv4NK5arrow10StructType13GetFieldIndexERKNSt6stringE)\

    :   Returns -1 if name not found or if there are multiple fields
        having the same name.

    <!-- -->

    std::vector\<int\> GetAllFieldIndices(const std::string &name) const[\#](#_CPPv4NK5arrow10StructType18GetAllFieldIndicesERKNSt6stringE)\

    :   Return the indices of all fields having this name in sorted
        order.

    <!-- -->

    [Result](support.html#_CPPv4I0EN5arrow6ResultE)\<std::shared_ptr\<[StructType](#classarrow_1_1_struct_type)\>\> AddField(int i, const std::shared_ptr\<[Field](#_CPPv4N5arrow5FieldE)\> &field) const[\#](#_CPPv4NK5arrow10StructType8AddFieldEiRKNSt10shared_ptrI5FieldEE)\

    :   Create a new [StructType](#classarrow_1_1_struct_type) with
        field added at given index.

    <!-- -->

    [Result](support.html#_CPPv4I0EN5arrow6ResultE)\<std::shared_ptr\<[StructType](#classarrow_1_1_struct_type)\>\> RemoveField(int i) const[\#](#_CPPv4NK5arrow10StructType11RemoveFieldEi)\

    :   Create a new [StructType](#classarrow_1_1_struct_type) by
        removing the field at given index.

    <!-- -->

    [Result](support.html#_CPPv4I0EN5arrow6ResultE)\<std::shared_ptr\<[StructType](#classarrow_1_1_struct_type)\>\> SetField(int i, const std::shared_ptr\<[Field](#_CPPv4N5arrow5FieldE)\> &field) const[\#](#_CPPv4NK5arrow10StructType8SetFieldEiRKNSt10shared_ptrI5FieldEE)\

    :   Create a new [StructType](#classarrow_1_1_struct_type) by
        changing the field at given index.

<!-- -->

class UnionType : public arrow::NestedType[\#](#_CPPv4N5arrow9UnionTypeE)\

:        

    *#include \<arrow/type.h\>*

    Base type class for union data.

    Subclassed by
    [arrow::DenseUnionType](#classarrow_1_1_dense_union_type),
    [arrow::SparseUnionType](#classarrow_1_1_sparse_union_type)

    Public Functions

    virtual DataTypeLayout layout() const override[\#](#_CPPv4NK5arrow9UnionType6layoutEv)\

    :   Return the data type layout.

        Children are not included.

        Note

        Experimental API

    <!-- -->

    virtual std::string ToString(bool show_metadata = false) const override[\#](#_CPPv4NK5arrow9UnionType8ToStringEb)\

    :   A string representation of the type, including any children.

    <!-- -->

    inline const std::vector\<int8_t\> &type_codes() const[\#](#_CPPv4NK5arrow9UnionType10type_codesEv)\

    :   The array of logical type ids.

        For example, the first type in the union might be denoted by the
        id 5 (instead of 0).

    <!-- -->

    inline const std::vector\<int\> &child_ids() const[\#](#_CPPv4NK5arrow9UnionType9child_idsEv)\

    :   An array mapping logical type ids to physical child ids.

<!-- -->

class SparseUnionType : public arrow::[UnionType](#_CPPv4N5arrow9UnionTypeE)[\#](#_CPPv4N5arrow15SparseUnionTypeE)\

:        

    *#include \<arrow/type.h\>*

    Concrete type class for sparse union data.

    A sparse union is a nested type where each logical value is taken
    from a single child. A buffer of 8-bit type ids indicates which
    child a given logical value is to be taken from.

    In a sparse union, each child array should have the same length as
    the union array, regardless of the actual number of union values
    that refer to it.

    Note that, unlike most other types, unions don't have a top-level
    validity bitmap.

    Public Functions

    inline virtual std::string name() const override[\#](#_CPPv4NK5arrow15SparseUnionType4nameEv)\

    :   A string name of the type, omitting any child fields.

        **Since**

        :   0.7.0

<!-- -->

class DenseUnionType : public arrow::[UnionType](#_CPPv4N5arrow9UnionTypeE)[\#](#_CPPv4N5arrow14DenseUnionTypeE)\

:        

    *#include \<arrow/type.h\>*

    Concrete type class for dense union data.

    A dense union is a nested type where each logical value is taken
    from a single child, at a specific offset. A buffer of 8-bit type
    ids indicates which child a given logical value is to be taken from,
    and a buffer of 32-bit offsets indicates at which physical position
    in the given child array the logical value is to be taken from.

    Unlike a sparse union, a dense union allows encoding only the child
    array values which are actually referred to by the union array. This
    is counterbalanced by the additional footprint of the offsets
    buffer, and the additional indirection cost when looking up values.

    Note that, unlike most other types, unions don't have a top-level
    validity bitmap.

    Public Functions

    inline virtual std::string name() const override[\#](#_CPPv4NK5arrow14DenseUnionType4nameEv)\

    :   A string name of the type, omitting any child fields.

        **Since**

        :   0.7.0

<!-- -->

class RunEndEncodedType : public arrow::NestedType[\#](#_CPPv4N5arrow17RunEndEncodedTypeE)\

:        

    *#include \<arrow/type.h\>*

    Type class for run-end encoded data.

    Public Functions

    inline virtual DataTypeLayout layout() const override[\#](#_CPPv4NK5arrow17RunEndEncodedType6layoutEv)\

    :   Return the data type layout.

        Children are not included.

        Note

        Experimental API

    <!-- -->

    virtual std::string ToString(bool show_metadata = false) const override[\#](#_CPPv4NK5arrow17RunEndEncodedType8ToStringEb)\

    :   A string representation of the type, including any children.

    <!-- -->

    inline virtual std::string name() const override[\#](#_CPPv4NK5arrow17RunEndEncodedType4nameEv)\

    :   A string name of the type, omitting any child fields.

        **Since**

        :   0.7.0

:::

::: section
### Dictionary-encoded[\#](#dictionary-encoded)

class DictionaryType : public arrow::FixedWidthType[\#](#_CPPv4N5arrow14DictionaryTypeE)\

:   Dictionary-encoded value type with data-dependent dictionary.

    Indices are represented by any integer types.

    Public Functions

    virtual std::string ToString(bool show_metadata = false) const override[\#](#_CPPv4NK5arrow14DictionaryType8ToStringEb)\

    :   A string representation of the type, including any children.

    <!-- -->

    inline virtual std::string name() const override[\#](#_CPPv4NK5arrow14DictionaryType4nameEv)\

    :   A string name of the type, omitting any child fields.

        **Since**

        :   0.7.0

    <!-- -->

    virtual int bit_width() const override[\#](#_CPPv4NK5arrow14DictionaryType9bit_widthEv)\

    :   Returns the type's fixed bit width, if any.

        Returns -1 for non-fixed-width types, and should only be used
        for subclasses of FixedWidthType

    <!-- -->

    virtual DataTypeLayout layout() const override[\#](#_CPPv4NK5arrow14DictionaryType6layoutEv)\

    :   Return the data type layout.

        Children are not included.

        Note

        Experimental API

:::

::: section
### Extension types[\#](#extension-types)

class ExtensionType : public arrow::[DataType](#_CPPv4N5arrow8DataTypeE)[\#](#_CPPv4N5arrow13ExtensionTypeE)\

:   The base class for custom / user-defined types.

    Subclassed by
    [arrow::extension::Bool8Type](extension.html#classarrow_1_1extension_1_1_bool8_type),
    [arrow::extension::FixedShapeTensorType](extension.html#classarrow_1_1extension_1_1_fixed_shape_tensor_type),
    [arrow::extension::JsonExtensionType](extension.html#classarrow_1_1extension_1_1_json_extension_type),
    [arrow::extension::OpaqueType](extension.html#classarrow_1_1extension_1_1_opaque_type),
    [arrow::extension::UuidType](extension.html#classarrow_1_1extension_1_1_uuid_type)

    Public Functions

    inline const std::shared_ptr\<[DataType](#_CPPv4N5arrow8DataTypeE)\> &storage_type() const[\#](#_CPPv4NK5arrow13ExtensionType12storage_typeEv)\

    :   The type of array used to represent this extension type's data.

    <!-- -->

    inline virtual Type::[type](#_CPPv4N5arrow4Type4typeE) storage_id() const override[\#](#_CPPv4NK5arrow13ExtensionType10storage_idEv)\

    :   Return the type category of the storage type.

    <!-- -->

    virtual DataTypeLayout layout() const override[\#](#_CPPv4NK5arrow13ExtensionType6layoutEv)\

    :   Return the data type layout.

        Children are not included.

        Note

        Experimental API

    <!-- -->

    virtual std::string ToString(bool show_metadata = false) const override[\#](#_CPPv4NK5arrow13ExtensionType8ToStringEb)\

    :   A string representation of the type, including any children.

    <!-- -->

    inline virtual std::string name() const override[\#](#_CPPv4NK5arrow13ExtensionType4nameEv)\

    :   A string name of the type, omitting any child fields.

        **Since**

        :   0.7.0

    <!-- -->

    inline virtual int32_t byte_width() const override[\#](#_CPPv4NK5arrow13ExtensionType10byte_widthEv)\

    :   Returns the type's fixed byte width, if any.

        Returns -1 for non-fixed-width types, and should only be used
        for subclasses of FixedWidthType

    <!-- -->

    inline virtual int bit_width() const override[\#](#_CPPv4NK5arrow13ExtensionType9bit_widthEv)\

    :   Returns the type's fixed bit width, if any.

        Returns -1 for non-fixed-width types, and should only be used
        for subclasses of FixedWidthType

    <!-- -->

    virtual std::string extension_name() const = 0[\#](#_CPPv4NK5arrow13ExtensionType14extension_nameEv)\

    :   Unique name of extension type used to identify type for
        serialization.

        Returns:

        :   the string name of the extension

    <!-- -->

    virtual bool ExtensionEquals(const [ExtensionType](#_CPPv4N5arrow13ExtensionTypeE) &other) const = 0[\#](#_CPPv4NK5arrow13ExtensionType15ExtensionEqualsERK13ExtensionType)\

    :   Determine if two instances of the same extension types are
        equal.

        Invoked from
        [ExtensionType::Equals](#classarrow_1_1_data_type_1aaf003113bb8f4c51a03a16f4b27a52bb)

        Parameters:

        :   **other** -- **\[in\]** the type to compare this type with

        Returns:

        :   bool true if type instances are equal

    <!-- -->

    virtual std::shared_ptr\<[Array](array.html#_CPPv4N5arrow5ArrayE)\> MakeArray(std::shared_ptr\<[ArrayData](array.html#_CPPv4N5arrow9ArrayDataE)\> data) const = 0[\#](#_CPPv4NK5arrow13ExtensionType9MakeArrayENSt10shared_ptrI9ArrayDataEE)\

    :   Wrap built-in [Array](array.html#classarrow_1_1_array) type in a
        user-defined
        [ExtensionArray](array.html#classarrow_1_1_extension_array)
        instance.

        Parameters:

        :   **data** -- **\[in\]** the physical storage for the
            extension type

    <!-- -->

    virtual [Result](support.html#_CPPv4I0EN5arrow6ResultE)\<std::shared_ptr\<[DataType](#_CPPv4N5arrow8DataTypeE)\>\> Deserialize(std::shared_ptr\<[DataType](#_CPPv4N5arrow8DataTypeE)\> storage_type, const std::string &serialized_data) const = 0[\#](#_CPPv4NK5arrow13ExtensionType11DeserializeENSt10shared_ptrI8DataTypeEERKNSt6stringE)\

    :   Create an instance of the
        [ExtensionType](#classarrow_1_1_extension_type) given the actual
        storage type and the serialized representation.

        Parameters:

        :   -   **storage_type** -- **\[in\]** the physical storage type
                of the extension

            -   **serialized_data** -- **\[in\]** the serialized
                representation produced by Serialize

    <!-- -->

    virtual std::string Serialize() const = 0[\#](#_CPPv4NK5arrow13ExtensionType9SerializeEv)\

    :   Create a serialized representation of the extension type's
        metadata.

        The storage type will be handled automatically in IPC code paths

        Returns:

        :   the serialized representation

    Public Static Functions

    static std::shared_ptr\<[Array](array.html#_CPPv4N5arrow5ArrayE)\> WrapArray(const std::shared_ptr\<[DataType](#_CPPv4N5arrow8DataTypeE)\> &ext_type, const std::shared_ptr\<[Array](array.html#_CPPv4N5arrow5ArrayE)\> &storage)[\#](#_CPPv4N5arrow13ExtensionType9WrapArrayERKNSt10shared_ptrI8DataTypeEERKNSt10shared_ptrI5ArrayEE)\

    :   Wrap the given storage array as an extension array.

    <!-- -->

    static std::shared_ptr\<[ChunkedArray](array.html#_CPPv4N5arrow12ChunkedArrayE)\> WrapArray(const std::shared_ptr\<[DataType](#_CPPv4N5arrow8DataTypeE)\> &ext_type, const std::shared_ptr\<[ChunkedArray](array.html#_CPPv4N5arrow12ChunkedArrayE)\> &storage)[\#](#_CPPv4N5arrow13ExtensionType9WrapArrayERKNSt10shared_ptrI8DataTypeEERKNSt10shared_ptrI12ChunkedArrayEE)\

    :   Wrap the given chunked storage array as a chunked extension
        array.

:::
:::::::::

:::: section
## Fields and Schemas[\#](#fields-and-schemas)

std::shared_ptr\<Field\> field(std::string name, std::shared_ptr\<DataType\> type, bool nullable = true, std::shared_ptr\<const KeyValueMetadata\> metadata = NULLPTR)[\#](#_CPPv45fieldNSt6stringENSt10shared_ptrI8DataTypeEEbNSt10shared_ptrIK16KeyValueMetadataEE)\

:   Create a [Field](#classarrow_1_1_field) instance.

    Parameters:

    :   -   **name** -- the field name

        -   **type** -- the field value type

        -   **nullable** -- whether the values are nullable, default
            true

        -   **metadata** -- any custom key-value metadata, default null

<!-- -->

std::shared_ptr\<Field\> field(std::string name, std::shared_ptr\<DataType\> type, std::shared_ptr\<const KeyValueMetadata\> metadata)[\#](#_CPPv45fieldNSt6stringENSt10shared_ptrI8DataTypeEENSt10shared_ptrIK16KeyValueMetadataEE)\

:   Create a [Field](#classarrow_1_1_field) instance with metadata.

    The field will be assumed to be nullable.

    Parameters:

    :   -   **name** -- the field name

        -   **type** -- the field value type

        -   **metadata** -- any custom key-value metadata

<!-- -->

std::shared_ptr\<Schema\> schema(FieldVector fields, std::shared_ptr\<const KeyValueMetadata\> metadata = NULLPTR)[\#](#_CPPv46schema11FieldVectorNSt10shared_ptrIK16KeyValueMetadataEE)\

:   Create a [Schema](#classarrow_1_1_schema) instance.

    Parameters:

    :   -   **fields** -- the schema's fields

        -   **metadata** -- any custom key-value metadata, default null

    Returns:

    :   schema shared_ptr to [Schema](#classarrow_1_1_schema)

<!-- -->

std::shared_ptr\<Schema\> schema(std::initializer_list\<std::pair\<std::string, std::shared_ptr\<DataType\>\>\> fields, std::shared_ptr\<const KeyValueMetadata\> metadata = NULLPTR)[\#](#_CPPv46schemaNSt16initializer_listINSt4pairINSt6stringENSt10shared_ptrI8DataTypeEEEEEE)\

:   Create a [Schema](#classarrow_1_1_schema) instance from (name, type)
    pairs.

    The schema's fields will all be nullable with no associated
    metadata.

    Parameters:

    :   -   **fields** -- (name, type) pairs of the schema's fields

        -   **metadata** -- any custom key-value metadata, default null

    Returns:

    :   schema shared_ptr to [Schema](#classarrow_1_1_schema)

<!-- -->

std::shared_ptr\<Schema\> schema(FieldVector fields, Endianness endianness, std::shared_ptr\<const KeyValueMetadata\> metadata = NULLPTR)[\#](#_CPPv46schema11FieldVector10EndiannessNSt10shared_ptrIK16KeyValueMetadataEE)\

:   Create a [Schema](#classarrow_1_1_schema) instance.

    Parameters:

    :   -   **fields** -- the schema's fields

        -   **endianness** -- the endianness of the data

        -   **metadata** -- any custom key-value metadata, default null

    Returns:

    :   schema shared_ptr to [Schema](#classarrow_1_1_schema)

<!-- -->

std::shared_ptr\<Schema\> schema(std::initializer_list\<std::pair\<std::string, std::shared_ptr\<DataType\>\>\> fields, Endianness endianness, std::shared_ptr\<const KeyValueMetadata\> metadata = NULLPTR)[\#](#_CPPv46schemaNSt16initializer_listINSt4pairINSt6stringENSt10shared_ptrI8DataTypeEEEEEE10EndiannessNSt10shared_ptrIK16KeyValueMetadataEE)\

:   Create a [Schema](#classarrow_1_1_schema) instance.

    The schema's fields will all be nullable with no associated
    metadata.

    Parameters:

    :   -   **fields** -- (name, type) pairs of the schema's fields

        -   **endianness** -- the endianness of the data

        -   **metadata** -- any custom key-value metadata, default null

    Returns:

    :   schema shared_ptr to [Schema](#classarrow_1_1_schema)

<!-- -->

class Field : public arrow::detail::Fingerprintable, public arrow::util::EqualityComparable\<[Field](#_CPPv4N5arrow5FieldE)\>[\#](#_CPPv4N5arrow5FieldE)\

:   The combination of a field name and data type, with optional
    metadata.

    Fields are used to describe the individual constituents of a nested
    [DataType](#classarrow_1_1_data_type) or a
    [Schema](#classarrow_1_1_schema).

    A field's metadata is represented by a
    [KeyValueMetadata](#classarrow_1_1_key_value_metadata) instance,
    which holds arbitrary key-value pairs.

    Public Functions

    inline std::shared_ptr\<const [KeyValueMetadata](#_CPPv4N5arrow16KeyValueMetadataE)\> metadata() const[\#](#_CPPv4NK5arrow5Field8metadataEv)\

    :   Return the field's attached metadata.

    <!-- -->

    bool HasMetadata() const[\#](#_CPPv4NK5arrow5Field11HasMetadataEv)\

    :   Return whether the field has non-empty metadata.

    <!-- -->

    std::shared_ptr\<[Field](#_CPPv4N5arrow5FieldE)\> WithMetadata(const std::shared_ptr\<const [KeyValueMetadata](#_CPPv4N5arrow16KeyValueMetadataE)\> &metadata) const[\#](#_CPPv4NK5arrow5Field12WithMetadataERKNSt10shared_ptrIK16KeyValueMetadataEE)\

    :   Return a copy of this field with the given metadata attached to
        it.

    <!-- -->

    std::shared_ptr\<[Field](#_CPPv4N5arrow5FieldE)\> WithMergedMetadata(const std::shared_ptr\<const [KeyValueMetadata](#_CPPv4N5arrow16KeyValueMetadataE)\> &metadata) const[\#](#_CPPv4NK5arrow5Field18WithMergedMetadataERKNSt10shared_ptrIK16KeyValueMetadataEE)\

    :   EXPERIMENTAL: Return a copy of this field with the given
        metadata merged with existing metadata (any colliding keys will
        be overridden by the passed metadata)

    <!-- -->

    std::shared_ptr\<[Field](#_CPPv4N5arrow5FieldE)\> RemoveMetadata() const[\#](#_CPPv4NK5arrow5Field14RemoveMetadataEv)\

    :   Return a copy of this field without any metadata attached to it.

    <!-- -->

    std::shared_ptr\<[Field](#_CPPv4N5arrow5FieldE)\> WithType(const std::shared_ptr\<[DataType](#_CPPv4N5arrow8DataTypeE)\> &type) const[\#](#_CPPv4NK5arrow5Field8WithTypeERKNSt10shared_ptrI8DataTypeEE)\

    :   Return a copy of this field with the replaced type.

    <!-- -->

    std::shared_ptr\<[Field](#_CPPv4N5arrow5FieldE)\> WithName(const std::string &name) const[\#](#_CPPv4NK5arrow5Field8WithNameERKNSt6stringE)\

    :   Return a copy of this field with the replaced name.

    <!-- -->

    std::shared_ptr\<[Field](#_CPPv4N5arrow5FieldE)\> WithNullable(bool nullable) const[\#](#_CPPv4NK5arrow5Field12WithNullableEb)\

    :   Return a copy of this field with the replaced nullability.

    <!-- -->

    [Result](support.html#_CPPv4I0EN5arrow6ResultE)\<std::shared_ptr\<[Field](#_CPPv4N5arrow5FieldE)\>\> MergeWith(const [Field](#_CPPv4N5arrow5FieldE) &other, [MergeOptions](#_CPPv4N5arrow5Field12MergeOptionsE) options = [MergeOptions](#_CPPv4N5arrow5Field12MergeOptionsE)::[Defaults](#_CPPv4N5arrow5Field12MergeOptions8DefaultsEv)()) const[\#](#_CPPv4NK5arrow5Field9MergeWithERK5Field12MergeOptions)\

    :   Merge the current field with a field of the same name.

        The two fields must be compatible, i.e:

        -   have the same name

        -   have the same type, or of compatible types according to
            `options`.

        The metadata of the current field is preserved; the metadata of
        the other field is discarded.

    <!-- -->

    bool Equals(const [Field](#_CPPv4N5arrow5FieldE) &other, bool check_metadata = false) const[\#](#_CPPv4NK5arrow5Field6EqualsERK5Fieldb)\

    :   Indicate if fields are equals.

        Parameters:

        :   -   **other** -- **\[in\]** field to check equality with.

            -   **check_metadata** -- **\[in\]** controls if it should
                check for metadata equality.

        Returns:

        :   true if fields are equal, false otherwise.

    <!-- -->

    bool IsCompatibleWith(const [Field](#_CPPv4N5arrow5FieldE) &other) const[\#](#_CPPv4NK5arrow5Field16IsCompatibleWithERK5Field)\

    :   Indicate if fields are compatibles.

        See the criteria of MergeWith.

        Returns:

        :   true if fields are compatible, false otherwise.

    <!-- -->

    std::string ToString(bool show_metadata = false) const[\#](#_CPPv4NK5arrow5Field8ToStringEb)\

    :   Return a string representation ot the field.

        Parameters:

        :   **show_metadata** -- **\[in\]** when true, if
            [KeyValueMetadata](#classarrow_1_1_key_value_metadata) is
            non-empty, print keys and values in the output

    <!-- -->

    inline const std::string &name() const[\#](#_CPPv4NK5arrow5Field4nameEv)\

    :   Return the field name.

    <!-- -->

    inline const std::shared_ptr\<[DataType](#_CPPv4N5arrow8DataTypeE)\> &type() const[\#](#_CPPv4NK5arrow5Field4typeEv)\

    :   Return the field data type.

    <!-- -->

    inline bool nullable() const[\#](#_CPPv4NK5arrow5Field8nullableEv)\

    :   Return whether the field is nullable.

    struct MergeOptions : public arrow::util::ToStringOstreamable\<[MergeOptions](#_CPPv4N5arrow5Field12MergeOptionsE)\>[\#](#_CPPv4N5arrow5Field12MergeOptionsE)\

    :   Options that control the behavior of `MergeWith`.

        Options are to be added to allow type conversions, including
        integer widening, promotion from integer to float, or conversion
        to or from boolean.

        Public Functions

        std::string ToString() const[\#](#_CPPv4NK5arrow5Field12MergeOptions8ToStringEv)\

        :   Get a human-readable representation of the options.

        Public Members

        bool promote_nullability = true[\#](#_CPPv4N5arrow5Field12MergeOptions19promote_nullabilityE)\

        :   If true, a [Field](#classarrow_1_1_field) of
            [NullType](#classarrow_1_1_null_type) can be unified with a
            [Field](#classarrow_1_1_field) of another type.

            The unified field will be of the other type and become
            nullable. Nullability will be promoted to the looser option
            (nullable if one is not nullable).

        <!-- -->

        bool promote_decimal = false[\#](#_CPPv4N5arrow5Field12MergeOptions15promote_decimalE)\

        :   Allow a decimal to be unified with another decimal of the
            same width, adjusting scale and precision as appropriate.

            May fail if the adjustment is not possible.

        <!-- -->

        bool promote_decimal_to_float = false[\#](#_CPPv4N5arrow5Field12MergeOptions24promote_decimal_to_floatE)\

        :   Allow a decimal to be promoted to a float.

            The float type will not itself be promoted (e.g.
            [Decimal128](utilities.html#classarrow_1_1_decimal128) +
            Float32 = Float32).

        <!-- -->

        bool promote_integer_to_decimal = false[\#](#_CPPv4N5arrow5Field12MergeOptions26promote_integer_to_decimalE)\

        :   Allow an integer to be promoted to a decimal.

            May fail if the decimal has insufficient precision to
            accommodate the integer (see promote_numeric_width).

        <!-- -->

        bool promote_integer_to_float = false[\#](#_CPPv4N5arrow5Field12MergeOptions24promote_integer_to_floatE)\

        :   Allow an integer of a given bit width to be promoted to a
            float; the result will be a float of an equal or greater bit
            width to both of the inputs.

            Examples:

            -   int8 + float32 = float32

            -   int32 + float32 = float64

            -   int32 + float64 = float64 Because an int32 cannot always
                be represented exactly in the 24 bits of a float32
                mantissa.

        <!-- -->

        bool promote_integer_sign = false[\#](#_CPPv4N5arrow5Field12MergeOptions20promote_integer_signE)\

        :   Allow an unsigned integer of a given bit width to be
            promoted to a signed integer that fits into the signed type:
            uint + int16 = int16 When widening is needed, set
            promote_numeric_width to true: uint16 + int16 = int32.

        <!-- -->

        bool promote_numeric_width = false[\#](#_CPPv4N5arrow5Field12MergeOptions21promote_numeric_widthE)\

        :   Allow an integer, float, or decimal of a given bit width to
            be promoted to an equivalent type of a greater bit width.

        <!-- -->

        bool promote_binary = false[\#](#_CPPv4N5arrow5Field12MergeOptions14promote_binaryE)\

        :   Allow strings to be promoted to binary types.

            Promotion of fixed size binary types to variable sized
            formats, and binary to large binary, and string to large
            string.

        <!-- -->

        bool promote_temporal_unit = false[\#](#_CPPv4N5arrow5Field12MergeOptions21promote_temporal_unitE)\

        :   Second to millisecond, Time32 to Time64, Time32(SECOND) to
            Time32(MILLI), etc.

        <!-- -->

        bool promote_list = false[\#](#_CPPv4N5arrow5Field12MergeOptions12promote_listE)\

        :   Allow promotion from a list to a large-list and from a
            fixed-size list to a variable sized list.

        <!-- -->

        bool promote_dictionary = false[\#](#_CPPv4N5arrow5Field12MergeOptions18promote_dictionaryE)\

        :   Unify dictionary index types and dictionary value types.

        <!-- -->

        bool promote_dictionary_ordered = false[\#](#_CPPv4N5arrow5Field12MergeOptions26promote_dictionary_orderedE)\

        :   Allow merging ordered and non-ordered dictionaries.

            The result will be ordered if and only if both inputs are
            ordered.

        Public Static Functions

        static inline [MergeOptions](#_CPPv4N5arrow5Field12MergeOptionsE) Defaults()[\#](#_CPPv4N5arrow5Field12MergeOptions8DefaultsEv)\

        :   Get default options. Only
            [NullType](#classarrow_1_1_null_type) will be merged with
            other types.

        <!-- -->

        static [MergeOptions](#_CPPv4N5arrow5Field12MergeOptionsE) Permissive()[\#](#_CPPv4N5arrow5Field12MergeOptions10PermissiveEv)\

        :   Get permissive options.

            All options are enabled, except promote_dictionary_ordered.

<!-- -->

class Schema : public arrow::detail::Fingerprintable, public arrow::util::EqualityComparable\<[Schema](#_CPPv4N5arrow6SchemaE)\>, public arrow::util::ToStringOstreamable\<[Schema](#_CPPv4N5arrow6SchemaE)\>[\#](#_CPPv4N5arrow6SchemaE)\

:   Sequence of [arrow::Field](#classarrow_1_1_field) objects describing
    the columns of a record batch or table data structure.

    Public Functions

    bool Equals(const [Schema](#_CPPv4N5arrow6SchemaE) &other, bool check_metadata = false) const[\#](#_CPPv4NK5arrow6Schema6EqualsERK6Schemab)\

    :   Returns true if all of the schema fields are equal.

    <!-- -->

    std::shared_ptr\<[Schema](#_CPPv4N5arrow6SchemaE)\> WithEndianness(Endianness endianness) const[\#](#_CPPv4NK5arrow6Schema14WithEndiannessE10Endianness)\

    :   Set endianness in the schema.

        Returns:

        :   new [Schema](#classarrow_1_1_schema)

    <!-- -->

    Endianness endianness() const[\#](#_CPPv4NK5arrow6Schema10endiannessEv)\

    :   Return endianness in the schema.

    <!-- -->

    bool is_native_endian() const[\#](#_CPPv4NK5arrow6Schema16is_native_endianEv)\

    :   Indicate if endianness is equal to platform-native endianness.

    <!-- -->

    int num_fields() const[\#](#_CPPv4NK5arrow6Schema10num_fieldsEv)\

    :   Return the number of fields (columns) in the schema.

    <!-- -->

    const std::shared_ptr\<[Field](#_CPPv4N5arrow5FieldE)\> &field(int i) const[\#](#_CPPv4NK5arrow6Schema5fieldEi)\

    :   Return the ith schema element. Does not boundscheck.

    <!-- -->

    std::shared_ptr\<[Field](#_CPPv4N5arrow5FieldE)\> GetFieldByName(std::string_view name) const[\#](#_CPPv4NK5arrow6Schema14GetFieldByNameENSt11string_viewE)\

    :   Returns null if name not found.

    <!-- -->

    FieldVector GetAllFieldsByName(std::string_view name) const[\#](#_CPPv4NK5arrow6Schema18GetAllFieldsByNameENSt11string_viewE)\

    :   Return the indices of all fields having this name in sorted
        order.

    <!-- -->

    int GetFieldIndex(std::string_view name) const[\#](#_CPPv4NK5arrow6Schema13GetFieldIndexENSt11string_viewE)\

    :   Returns -1 if name not found.

    <!-- -->

    std::vector\<int\> GetAllFieldIndices(std::string_view name) const[\#](#_CPPv4NK5arrow6Schema18GetAllFieldIndicesENSt11string_viewE)\

    :   Return the indices of all fields having this name.

    <!-- -->

    [Status](support.html#_CPPv4N5arrow6StatusE) CanReferenceFieldByName(std::string_view name) const[\#](#_CPPv4NK5arrow6Schema23CanReferenceFieldByNameENSt11string_viewE)\

    :   Indicate if field named `name` can be found unambiguously in the
        schema.

    <!-- -->

    [Status](support.html#_CPPv4N5arrow6StatusE) CanReferenceFieldsByNames(const std::vector\<std::string\> &names) const[\#](#_CPPv4NK5arrow6Schema25CanReferenceFieldsByNamesERKNSt6vectorINSt6stringEEE)\

    :   Indicate if fields named `names` can be found unambiguously in
        the schema.

    <!-- -->

    const std::shared_ptr\<const [KeyValueMetadata](#_CPPv4N5arrow16KeyValueMetadataE)\> &metadata() const[\#](#_CPPv4NK5arrow6Schema8metadataEv)\

    :   The custom key-value metadata, if any.

        Returns:

        :   metadata may be null

    <!-- -->

    std::string ToString(bool show_metadata = false) const[\#](#_CPPv4NK5arrow6Schema8ToStringEb)\

    :   Render a string representation of the schema suitable for
        debugging.

        Parameters:

        :   **show_metadata** -- **\[in\]** when true, if
            [KeyValueMetadata](#classarrow_1_1_key_value_metadata) is
            non-empty, print keys and values in the output

    <!-- -->

    [Result](support.html#_CPPv4I0EN5arrow6ResultE)\<std::shared_ptr\<[Schema](#classarrow_1_1_schema)\>\> WithNames(const std::vector\<std::string\> &names) const[\#](#_CPPv4NK5arrow6Schema9WithNamesERKNSt6vectorINSt6stringEEE)\

    :   Replace field names with new names.

        Parameters:

        :   **names** -- **\[in\]** new names

        Returns:

        :   new [Schema](#classarrow_1_1_schema)

    <!-- -->

    std::shared_ptr\<[Schema](#classarrow_1_1_schema)\> WithMetadata(const std::shared_ptr\<const [KeyValueMetadata](#_CPPv4N5arrow16KeyValueMetadataE)\> &metadata) const[\#](#_CPPv4NK5arrow6Schema12WithMetadataERKNSt10shared_ptrIK16KeyValueMetadataEE)\

    :   Replace key-value metadata with new metadata.

        Parameters:

        :   **metadata** -- **\[in\]** new
            [KeyValueMetadata](#classarrow_1_1_key_value_metadata)

        Returns:

        :   new [Schema](#classarrow_1_1_schema)

    <!-- -->

    std::shared_ptr\<[Schema](#classarrow_1_1_schema)\> RemoveMetadata() const[\#](#_CPPv4NK5arrow6Schema14RemoveMetadataEv)\

    :   Return copy of [Schema](#classarrow_1_1_schema) without the
        [KeyValueMetadata](#classarrow_1_1_key_value_metadata).

    <!-- -->

    bool HasMetadata() const[\#](#_CPPv4NK5arrow6Schema11HasMetadataEv)\

    :   Indicate that the [Schema](#classarrow_1_1_schema) has non-empty
        KevValueMetadata.

    <!-- -->

    bool HasDistinctFieldNames() const[\#](#_CPPv4NK5arrow6Schema21HasDistinctFieldNamesEv)\

    :   Indicate that the [Schema](#classarrow_1_1_schema) has distinct
        field names.

<!-- -->

class KeyValueMetadata[\#](#_CPPv4N5arrow16KeyValueMetadataE)\

:   A container for key-value pair type metadata. Not thread-safe.

::: section
### Helpers for looking up fields[\#](#helpers-for-looking-up-fields)

class FieldPath[\#](#_CPPv4N5arrow9FieldPathE)\

:   Represents a path to a nested field using indices of child fields.

    For example, given indices {5, 9, 3} the field would be retrieved
    with schema-\>field(5)-\>type()-\>field(9)-\>type()-\>field(3)

    Attempting to retrieve a child field using a
    [FieldPath](#classarrow_1_1_field_path) which is not valid for a
    given schema will raise an error. Invalid FieldPaths include:

    -   an index is out of range

    -   the path is empty (note: a default constructed
        [FieldPath](#classarrow_1_1_field_path) will be empty)

    FieldPaths provide a number of accessors for drilling down to
    potentially nested children. They are overloaded for convenience to
    support [Schema](#classarrow_1_1_schema) (returns a field),
    [DataType](#classarrow_1_1_data_type) (returns a child field),
    [Field](#classarrow_1_1_field) (returns a child field of this
    field's type) [Array](array.html#classarrow_1_1_array) (returns a
    child array), [RecordBatch](table.html#classarrow_1_1_record_batch)
    (returns a column).

    Public Functions

    FieldPath() = default[\#](#_CPPv4N5arrow9FieldPath9FieldPathEv)\

    :   

    <!-- -->

    inline FieldPath(std::vector\<int\> indices)[\#](#_CPPv4N5arrow9FieldPath9FieldPathENSt6vectorIiEE)\

    :   

    <!-- -->

    inline FieldPath(std::initializer_list\<int\> indices)[\#](#_CPPv4N5arrow9FieldPath9FieldPathENSt16initializer_listIiEE)\

    :   

    <!-- -->

    std::string ToString() const[\#](#_CPPv4NK5arrow9FieldPath8ToStringEv)\

    :   

    <!-- -->

    size_t hash() const[\#](#_CPPv4NK5arrow9FieldPath4hashEv)\

    :   

    <!-- -->

    inline bool empty() const[\#](#_CPPv4NK5arrow9FieldPath5emptyEv)\

    :   

    <!-- -->

    inline bool operator==(const [FieldPath](#_CPPv4N5arrow9FieldPathE) &other) const[\#](#_CPPv4NK5arrow9FieldPatheqERK9FieldPath)\

    :   

    <!-- -->

    inline bool operator!=(const [FieldPath](#_CPPv4N5arrow9FieldPathE) &other) const[\#](#_CPPv4NK5arrow9FieldPathneERK9FieldPath)\

    :   

    <!-- -->

    inline const std::vector\<int\> &indices() const[\#](#_CPPv4NK5arrow9FieldPath7indicesEv)\

    :   

    <!-- -->

    inline int operator\[\](size_t i) const[\#](#_CPPv4NK5arrow9FieldPathixE6size_t)\

    :   

    <!-- -->

    inline std::vector\<int\>::const_iterator begin() const[\#](#_CPPv4NK5arrow9FieldPath5beginEv)\

    :   

    <!-- -->

    inline std::vector\<int\>::const_iterator end() const[\#](#_CPPv4NK5arrow9FieldPath3endEv)\

    :   

    <!-- -->

    [Result](support.html#_CPPv4I0EN5arrow6ResultE)\<std::shared_ptr\<[Field](#_CPPv4N5arrow5FieldE)\>\> Get(const [Schema](#_CPPv4N5arrow6SchemaE) &schema) const[\#](#_CPPv4NK5arrow9FieldPath3GetERK6Schema)\

    :   Retrieve the referenced child [Field](#classarrow_1_1_field)
        from a [Schema](#classarrow_1_1_schema),
        [Field](#classarrow_1_1_field), or
        [DataType](#classarrow_1_1_data_type).

    <!-- -->

    [Result](support.html#_CPPv4I0EN5arrow6ResultE)\<std::shared_ptr\<[Field](#_CPPv4N5arrow5FieldE)\>\> Get(const [Field](#_CPPv4N5arrow5FieldE) &field) const[\#](#_CPPv4NK5arrow9FieldPath3GetERK5Field)\

    :   

    <!-- -->

    [Result](support.html#_CPPv4I0EN5arrow6ResultE)\<std::shared_ptr\<[Field](#_CPPv4N5arrow5FieldE)\>\> Get(const [DataType](#_CPPv4N5arrow8DataTypeE) &type) const[\#](#_CPPv4NK5arrow9FieldPath3GetERK8DataType)\

    :   

    <!-- -->

    [Result](support.html#_CPPv4I0EN5arrow6ResultE)\<std::shared_ptr\<[Field](#_CPPv4N5arrow5FieldE)\>\> Get(const FieldVector &fields) const[\#](#_CPPv4NK5arrow9FieldPath3GetERK11FieldVector)\

    :   

    <!-- -->

    [Result](support.html#_CPPv4I0EN5arrow6ResultE)\<std::shared_ptr\<[Array](array.html#_CPPv4N5arrow5ArrayE)\>\> Get(const [RecordBatch](table.html#_CPPv4N5arrow11RecordBatchE) &batch) const[\#](#_CPPv4NK5arrow9FieldPath3GetERK11RecordBatch)\

    :   Retrieve the referenced column from a
        [RecordBatch](table.html#classarrow_1_1_record_batch) or
        [Table](table.html#classarrow_1_1_table).

    <!-- -->

    [Result](support.html#_CPPv4I0EN5arrow6ResultE)\<std::shared_ptr\<[ChunkedArray](array.html#_CPPv4N5arrow12ChunkedArrayE)\>\> Get(const [Table](table.html#classarrow_1_1_table) &table) const[\#](#_CPPv4NK5arrow9FieldPath3GetERK5Table)\

    :   

    <!-- -->

    [Result](support.html#_CPPv4I0EN5arrow6ResultE)\<std::shared_ptr\<[Array](array.html#_CPPv4N5arrow5ArrayE)\>\> Get(const [Array](array.html#_CPPv4N5arrow5ArrayE) &array) const[\#](#_CPPv4NK5arrow9FieldPath3GetERK5Array)\

    :   Retrieve the referenced child from an
        [Array](array.html#classarrow_1_1_array) or
        [ArrayData](array.html#structarrow_1_1_array_data).

    <!-- -->

    [Result](support.html#_CPPv4I0EN5arrow6ResultE)\<std::shared_ptr\<[ArrayData](array.html#_CPPv4N5arrow9ArrayDataE)\>\> Get(const [ArrayData](array.html#_CPPv4N5arrow9ArrayDataE) &data) const[\#](#_CPPv4NK5arrow9FieldPath3GetERK9ArrayData)\

    :   

    <!-- -->

    [Result](support.html#_CPPv4I0EN5arrow6ResultE)\<std::shared_ptr\<[ChunkedArray](array.html#_CPPv4N5arrow12ChunkedArrayE)\>\> Get(const [ChunkedArray](array.html#_CPPv4N5arrow12ChunkedArrayE) &chunked_array) const[\#](#_CPPv4NK5arrow9FieldPath3GetERK12ChunkedArray)\

    :   Retrieve the referenced child from a
        [ChunkedArray](array.html#classarrow_1_1_chunked_array).

    <!-- -->

    [Result](support.html#_CPPv4I0EN5arrow6ResultE)\<std::shared_ptr\<[Array](array.html#_CPPv4N5arrow5ArrayE)\>\> GetFlattened(const [Array](array.html#_CPPv4N5arrow5ArrayE) &array, [MemoryPool](memory.html#_CPPv4N5arrow10MemoryPoolE) \*pool = NULLPTR) const[\#](#_CPPv4NK5arrow9FieldPath12GetFlattenedERK5ArrayP10MemoryPool)\

    :   Retrieve the referenced child/column from an
        [Array](array.html#classarrow_1_1_array),
        [ArrayData](array.html#structarrow_1_1_array_data),
        [ChunkedArray](array.html#classarrow_1_1_chunked_array),
        [RecordBatch](table.html#classarrow_1_1_record_batch), or
        [Table](table.html#classarrow_1_1_table).

        Unlike
        [`FieldPath::Get`](#classarrow_1_1_field_path_1aae7a713d95226aae34a97952417d1421),
        these variants are not zero-copy and the retrieved child's null
        bitmap is ANDed with its ancestors'

    <!-- -->

    [Result](support.html#_CPPv4I0EN5arrow6ResultE)\<std::shared_ptr\<[ArrayData](array.html#_CPPv4N5arrow9ArrayDataE)\>\> GetFlattened(const [ArrayData](array.html#_CPPv4N5arrow9ArrayDataE) &data, [MemoryPool](memory.html#_CPPv4N5arrow10MemoryPoolE) \*pool = NULLPTR) const[\#](#_CPPv4NK5arrow9FieldPath12GetFlattenedERK9ArrayDataP10MemoryPool)\

    :   

    <!-- -->

    [Result](support.html#_CPPv4I0EN5arrow6ResultE)\<std::shared_ptr\<[ChunkedArray](array.html#_CPPv4N5arrow12ChunkedArrayE)\>\> GetFlattened(const [ChunkedArray](array.html#_CPPv4N5arrow12ChunkedArrayE) &chunked_array, [MemoryPool](memory.html#_CPPv4N5arrow10MemoryPoolE) \*pool = NULLPTR) const[\#](#_CPPv4NK5arrow9FieldPath12GetFlattenedERK12ChunkedArrayP10MemoryPool)\

    :   

    <!-- -->

    [Result](support.html#_CPPv4I0EN5arrow6ResultE)\<std::shared_ptr\<[Array](array.html#_CPPv4N5arrow5ArrayE)\>\> GetFlattened(const [RecordBatch](table.html#_CPPv4N5arrow11RecordBatchE) &batch, [MemoryPool](memory.html#_CPPv4N5arrow10MemoryPoolE) \*pool = NULLPTR) const[\#](#_CPPv4NK5arrow9FieldPath12GetFlattenedERK11RecordBatchP10MemoryPool)\

    :   

    <!-- -->

    [Result](support.html#_CPPv4I0EN5arrow6ResultE)\<std::shared_ptr\<[ChunkedArray](array.html#_CPPv4N5arrow12ChunkedArrayE)\>\> GetFlattened(const [Table](table.html#classarrow_1_1_table) &table, [MemoryPool](memory.html#_CPPv4N5arrow10MemoryPoolE) \*pool = NULLPTR) const[\#](#_CPPv4NK5arrow9FieldPath12GetFlattenedERK5TableP10MemoryPool)\

    :   

    Public Static Functions

    static [Result](support.html#_CPPv4I0EN5arrow6ResultE)\<std::shared_ptr\<[Schema](#classarrow_1_1_schema)\>\> GetAll(const [Schema](#classarrow_1_1_schema) &schema, const std::vector\<[FieldPath](#classarrow_1_1_field_path)\> &paths)[\#](#_CPPv4N5arrow9FieldPath6GetAllERK6SchemaRKNSt6vectorI9FieldPathEE)\

    :   

    struct Hash[\#](#_CPPv4N5arrow9FieldPath4HashE)\

    :        

        Public Functions

        inline size_t operator()(const [FieldPath](#classarrow_1_1_field_path) &path) const[\#](#_CPPv4NK5arrow9FieldPath4HashclERK9FieldPath)\

        :   

<!-- -->

class FieldRef : public arrow::util::EqualityComparable\<[FieldRef](#classarrow_1_1_field_ref)\>[\#](#_CPPv4N5arrow8FieldRefE)\

:   Descriptor of a (potentially nested) field within a schema.

    Unlike [FieldPath](#classarrow_1_1_field_path) (which exclusively
    uses indices of child fields), [FieldRef](#classarrow_1_1_field_ref)
    may reference a field by name. It is intended to replace parameters
    like `int`` ``field_index` and
    `const`` ``std::string&`` ``field_name`; it can be implicitly
    constructed from either a field index or a name.

    Nested fields can be referenced as well. Given schema({field("a",
    struct\_({field("n",
    [null()](#group__type-factories_1ga4fa91684814cd41bf5c0771aa8ff9854))})),
    field("b",
    [int32()](#group__type-factories_1gacd210a54715c23fd8a6f48d0be91bf00))})

    the following all indicate the nested field named "n":
    [FieldRef](#classarrow_1_1_field_ref) ref1(0, 0);
    [FieldRef](#classarrow_1_1_field_ref) ref2("a", 0);
    [FieldRef](#classarrow_1_1_field_ref) ref3("a", "n");
    [FieldRef](#classarrow_1_1_field_ref) ref4(0, "n");
    ARROW_ASSIGN_OR_RAISE([FieldRef](#classarrow_1_1_field_ref) ref5,
    [FieldRef::FromDotPath](#classarrow_1_1_field_ref_1a943be70b898c444e5e9e81a948934f2f)(".a\[0\]"));

    FieldPaths matching a [FieldRef](#classarrow_1_1_field_ref) are
    retrieved using the member function FindAll. Multiple matches are
    possible because field names may be duplicated within a schema. For
    example: [Schema](#classarrow_1_1_schema) a_is_ambiguous({field("a",
    [int32()](#group__type-factories_1gacd210a54715c23fd8a6f48d0be91bf00)),
    field("a",
    [float32()](#group__type-factories_1gaecedd2fde4730a35c911b8c0b50e7ebe))});
    auto matches =
    [FieldRef](#classarrow_1_1_field_ref)("a").FindAll(a_is_ambiguous);
    assert(matches.size() == 2);
    assert(matches\[0\].Get(a_is_ambiguous)-\>Equals(a_is_ambiguous.field(0)));
    assert(matches\[1\].Get(a_is_ambiguous)-\>Equals(a_is_ambiguous.field(1)));

    Convenience accessors are available which raise a helpful error if
    the field is not found or ambiguous, and for immediately calling
    [FieldPath::Get](#classarrow_1_1_field_path_1aae7a713d95226aae34a97952417d1421)
    to retrieve any matching children: auto maybe_match =
    [FieldRef](#classarrow_1_1_field_ref)("struct",
    "field_i32").FindOneOrNone(schema); auto maybe_column =
    [FieldRef](#classarrow_1_1_field_ref)("struct",
    "field_i32").GetOne(some_table);

    Public Types

    template\<typename T\>\
    using GetType = decltype(std::declval\<[FieldPath](#classarrow_1_1_field_path)\>().Get(std::declval\<[T](#_CPPv4I0EN5arrow8FieldRef7GetTypeE)\>()).ValueOrDie())[\#](#_CPPv4I0EN5arrow8FieldRef7GetTypeE)\

    :   

    Public Functions

    FieldRef() = default[\#](#_CPPv4N5arrow8FieldRef8FieldRefEv)\

    :   

    <!-- -->

    FieldRef([FieldPath](#classarrow_1_1_field_path) indices)[\#](#_CPPv4N5arrow8FieldRef8FieldRefE9FieldPath)\

    :   Construct a [FieldRef](#classarrow_1_1_field_ref) using a string
        of indices.

        The reference will be retrieved as:
        schema.fields\[self.indices\[0\]\].type.fields\[self.indices\[1\]\]
        ...

        Empty indices are not valid.

    <!-- -->

    inline FieldRef(std::string name)[\#](#_CPPv4N5arrow8FieldRef8FieldRefENSt6stringE)\

    :   Construct a by-name [FieldRef](#classarrow_1_1_field_ref).

        Multiple fields may match a by-name
        [FieldRef](#classarrow_1_1_field_ref): \[f for f in
        schema.fields where f.name == self.name\]

    <!-- -->

    inline FieldRef(const char \*name)[\#](#_CPPv4N5arrow8FieldRef8FieldRefEPKc)\

    :   

    <!-- -->

    inline FieldRef(int index)[\#](#_CPPv4N5arrow8FieldRef8FieldRefEi)\

    :   Equivalent to a single index string of indices.

    <!-- -->

    inline explicit FieldRef(std::vector\<[FieldRef](#_CPPv4N5arrow8FieldRef8FieldRefENSt6vectorI8FieldRefEE)\> refs)[\#](#_CPPv4N5arrow8FieldRef8FieldRefENSt6vectorI8FieldRefEE)\

    :   Construct a nested [FieldRef](#classarrow_1_1_field_ref).

    <!-- -->

    template\<typename A0, typename A1, typename \...A\>\
    inline FieldRef([A0](#_CPPv4I00DpEN5arrow8FieldRef8FieldRefERR2A0RR2A1DpRR1A) &&a0, [A1](#_CPPv4I00DpEN5arrow8FieldRef8FieldRefERR2A0RR2A1DpRR1A) &&a1, [A](#_CPPv4I00DpEN5arrow8FieldRef8FieldRefERR2A0RR2A1DpRR1A)&&\... a)[\#](#_CPPv4I00DpEN5arrow8FieldRef8FieldRefERR2A0RR2A1DpRR1A)\

    :   Convenience constructor for nested FieldRefs: each argument will
        be used to construct a [FieldRef](#classarrow_1_1_field_ref).

    <!-- -->

    std::string ToDotPath() const[\#](#_CPPv4NK5arrow8FieldRef9ToDotPathEv)\

    :   

    <!-- -->

    inline bool Equals(const [FieldRef](#classarrow_1_1_field_ref) &other) const[\#](#_CPPv4NK5arrow8FieldRef6EqualsERK8FieldRef)\

    :   

    <!-- -->

    std::string ToString() const[\#](#_CPPv4NK5arrow8FieldRef8ToStringEv)\

    :   

    <!-- -->

    size_t hash() const[\#](#_CPPv4NK5arrow8FieldRef4hashEv)\

    :   

    <!-- -->

    inline explicit operator bool() const[\#](#_CPPv4NK5arrow8FieldRefcvbEv)\

    :   

    <!-- -->

    inline bool operator!() const[\#](#_CPPv4NK5arrow8FieldRefntEv)\

    :   

    <!-- -->

    inline bool IsFieldPath() const[\#](#_CPPv4NK5arrow8FieldRef11IsFieldPathEv)\

    :   

    <!-- -->

    inline bool IsName() const[\#](#_CPPv4NK5arrow8FieldRef6IsNameEv)\

    :   

    <!-- -->

    inline bool IsNested() const[\#](#_CPPv4NK5arrow8FieldRef8IsNestedEv)\

    :   

    <!-- -->

    inline bool IsNameSequence() const[\#](#_CPPv4NK5arrow8FieldRef14IsNameSequenceEv)\

    :   Return true if this ref is a name or a nested sequence of only
        names.

        Useful for determining if iteration is possible without
        recursion or inner loops

    <!-- -->

    inline const [FieldPath](#classarrow_1_1_field_path) \*field_path() const[\#](#_CPPv4NK5arrow8FieldRef10field_pathEv)\

    :   

    <!-- -->

    inline const std::string \*name() const[\#](#_CPPv4NK5arrow8FieldRef4nameEv)\

    :   

    <!-- -->

    inline const std::vector\<[FieldRef](#classarrow_1_1_field_ref)\> \*nested_refs() const[\#](#_CPPv4NK5arrow8FieldRef11nested_refsEv)\

    :   

    <!-- -->

    std::vector\<[FieldPath](#classarrow_1_1_field_path)\> FindAll(const [Schema](#classarrow_1_1_schema) &schema) const[\#](#_CPPv4NK5arrow8FieldRef7FindAllERK6Schema)\

    :   Retrieve [FieldPath](#classarrow_1_1_field_path) of every child
        field which matches this [FieldRef](#classarrow_1_1_field_ref).

    <!-- -->

    std::vector\<[FieldPath](#classarrow_1_1_field_path)\> FindAll(const [Field](#_CPPv4N5arrow5FieldE) &field) const[\#](#_CPPv4NK5arrow8FieldRef7FindAllERK5Field)\

    :   

    <!-- -->

    std::vector\<[FieldPath](#classarrow_1_1_field_path)\> FindAll(const [DataType](#classarrow_1_1_data_type) &type) const[\#](#_CPPv4NK5arrow8FieldRef7FindAllERK8DataType)\

    :   

    <!-- -->

    std::vector\<[FieldPath](#classarrow_1_1_field_path)\> FindAll(const FieldVector &fields) const[\#](#_CPPv4NK5arrow8FieldRef7FindAllERK11FieldVector)\

    :   

    <!-- -->

    std::vector\<[FieldPath](#classarrow_1_1_field_path)\> FindAll(const [ArrayData](array.html#_CPPv4N5arrow9ArrayDataE) &array) const[\#](#_CPPv4NK5arrow8FieldRef7FindAllERK9ArrayData)\

    :   Convenience function which applies FindAll to arg's type or
        schema.

    <!-- -->

    std::vector\<[FieldPath](#classarrow_1_1_field_path)\> FindAll(const [Array](array.html#_CPPv4N5arrow5ArrayE) &array) const[\#](#_CPPv4NK5arrow8FieldRef7FindAllERK5Array)\

    :   

    <!-- -->

    std::vector\<[FieldPath](#classarrow_1_1_field_path)\> FindAll(const [ChunkedArray](array.html#_CPPv4N5arrow12ChunkedArrayE) &chunked_array) const[\#](#_CPPv4NK5arrow8FieldRef7FindAllERK12ChunkedArray)\

    :   

    <!-- -->

    std::vector\<[FieldPath](#classarrow_1_1_field_path)\> FindAll(const [RecordBatch](table.html#_CPPv4N5arrow11RecordBatchE) &batch) const[\#](#_CPPv4NK5arrow8FieldRef7FindAllERK11RecordBatch)\

    :   

    <!-- -->

    std::vector\<[FieldPath](#classarrow_1_1_field_path)\> FindAll(const [Table](table.html#classarrow_1_1_table) &table) const[\#](#_CPPv4NK5arrow8FieldRef7FindAllERK5Table)\

    :   

    <!-- -->

    template\<typename T\>\
    inline [Status](support.html#_CPPv4N5arrow6StatusE) CheckNonEmpty(const std::vector\<[FieldPath](#classarrow_1_1_field_path)\> &matches, const [T](#_CPPv4I0ENK5arrow8FieldRef13CheckNonEmptyE6StatusRKNSt6vectorI9FieldPathEERK1T) &root) const[\#](#_CPPv4I0ENK5arrow8FieldRef13CheckNonEmptyE6StatusRKNSt6vectorI9FieldPathEERK1T)\

    :   Convenience function: raise an error if matches is empty.

    <!-- -->

    template\<typename T\>\
    inline [Status](support.html#_CPPv4N5arrow6StatusE) CheckNonMultiple(const std::vector\<[FieldPath](#classarrow_1_1_field_path)\> &matches, const [T](#_CPPv4I0ENK5arrow8FieldRef16CheckNonMultipleE6StatusRKNSt6vectorI9FieldPathEERK1T) &root) const[\#](#_CPPv4I0ENK5arrow8FieldRef16CheckNonMultipleE6StatusRKNSt6vectorI9FieldPathEERK1T)\

    :   Convenience function: raise an error if matches contains
        multiple FieldPaths.

    <!-- -->

    template\<typename T\>\
    inline [Result](support.html#_CPPv4I0EN5arrow6ResultE)\<[FieldPath](#classarrow_1_1_field_path)\> FindOne(const [T](#_CPPv4I0ENK5arrow8FieldRef7FindOneE6ResultI9FieldPathERK1T) &root) const[\#](#_CPPv4I0ENK5arrow8FieldRef7FindOneE6ResultI9FieldPathERK1T)\

    :   Retrieve [FieldPath](#classarrow_1_1_field_path) of a single
        child field which matches this
        [FieldRef](#classarrow_1_1_field_ref).

        Emit an error if none or multiple match.

    <!-- -->

    template\<typename T\>\
    inline [Result](support.html#_CPPv4I0EN5arrow6ResultE)\<[FieldPath](#classarrow_1_1_field_path)\> FindOneOrNone(const [T](#_CPPv4I0ENK5arrow8FieldRef13FindOneOrNoneE6ResultI9FieldPathERK1T) &root) const[\#](#_CPPv4I0ENK5arrow8FieldRef13FindOneOrNoneE6ResultI9FieldPathERK1T)\

    :   Retrieve [FieldPath](#classarrow_1_1_field_path) of a single
        child field which matches this
        [FieldRef](#classarrow_1_1_field_ref).

        Emit an error if multiple match. An empty (invalid)
        [FieldPath](#classarrow_1_1_field_path) will be returned if none
        match.

    <!-- -->

    template\<typename T\>\
    inline std::vector\<[GetType](#_CPPv4I0EN5arrow8FieldRef7GetTypeE)\<[T](#_CPPv4I0ENK5arrow8FieldRef6GetAllENSt6vectorI7GetTypeI1TEEERK1T)\>\> GetAll(const [T](#_CPPv4I0ENK5arrow8FieldRef6GetAllENSt6vectorI7GetTypeI1TEEERK1T) &root) const[\#](#_CPPv4I0ENK5arrow8FieldRef6GetAllENSt6vectorI7GetTypeI1TEEERK1T)\

    :   Get all children matching this
        [FieldRef](#classarrow_1_1_field_ref).

    <!-- -->

    template\<typename T\>\
    inline [Result](support.html#_CPPv4I0EN5arrow6ResultE)\<std::vector\<[GetType](#_CPPv4I0EN5arrow8FieldRef7GetTypeE)\<[T](#_CPPv4I0ENK5arrow8FieldRef15GetAllFlattenedE6ResultINSt6vectorI7GetTypeI1TEEEERK1TP10MemoryPool)\>\>\> GetAllFlattened(const [T](#_CPPv4I0ENK5arrow8FieldRef15GetAllFlattenedE6ResultINSt6vectorI7GetTypeI1TEEEERK1TP10MemoryPool) &root, [MemoryPool](memory.html#_CPPv4N5arrow10MemoryPoolE) \*pool = NULLPTR) const[\#](#_CPPv4I0ENK5arrow8FieldRef15GetAllFlattenedE6ResultINSt6vectorI7GetTypeI1TEEEERK1TP10MemoryPool)\

    :   Get all children matching this
        [FieldRef](#classarrow_1_1_field_ref).

        Unlike
        [`FieldRef::GetAll`](#classarrow_1_1_field_ref_1adde1d5b641c525966acde09e008a5042),
        this variant is not zero-copy and the retrieved children's null
        bitmaps are ANDed with their ancestors'

    <!-- -->

    template\<typename T\>\
    inline [Result](support.html#_CPPv4I0EN5arrow6ResultE)\<[GetType](#_CPPv4I0EN5arrow8FieldRef7GetTypeE)\<[T](#_CPPv4I0ENK5arrow8FieldRef6GetOneE6ResultI7GetTypeI1TEERK1T)\>\> GetOne(const [T](#_CPPv4I0ENK5arrow8FieldRef6GetOneE6ResultI7GetTypeI1TEERK1T) &root) const[\#](#_CPPv4I0ENK5arrow8FieldRef6GetOneE6ResultI7GetTypeI1TEERK1T)\

    :   Get the single child matching this
        [FieldRef](#classarrow_1_1_field_ref).

        Emit an error if none or multiple match.

    <!-- -->

    template\<typename T\>\
    inline [Result](support.html#_CPPv4I0EN5arrow6ResultE)\<[GetType](#_CPPv4I0EN5arrow8FieldRef7GetTypeE)\<[T](#_CPPv4I0ENK5arrow8FieldRef15GetOneFlattenedE6ResultI7GetTypeI1TEERK1TP10MemoryPool)\>\> GetOneFlattened(const [T](#_CPPv4I0ENK5arrow8FieldRef15GetOneFlattenedE6ResultI7GetTypeI1TEERK1TP10MemoryPool) &root, [MemoryPool](memory.html#_CPPv4N5arrow10MemoryPoolE) \*pool = NULLPTR) const[\#](#_CPPv4I0ENK5arrow8FieldRef15GetOneFlattenedE6ResultI7GetTypeI1TEERK1TP10MemoryPool)\

    :   Get the single child matching this
        [FieldRef](#classarrow_1_1_field_ref).

        Unlike
        [`FieldRef::GetOne`](#classarrow_1_1_field_ref_1a433f893e6d000245e75ac4565656f694),
        this variant is not zero-copy and the retrieved child's null
        bitmap is ANDed with its ancestors'

    <!-- -->

    template\<typename T\>\
    inline [Result](support.html#_CPPv4I0EN5arrow6ResultE)\<[GetType](#_CPPv4I0EN5arrow8FieldRef7GetTypeE)\<[T](#_CPPv4I0ENK5arrow8FieldRef12GetOneOrNoneE6ResultI7GetTypeI1TEERK1T)\>\> GetOneOrNone(const [T](#_CPPv4I0ENK5arrow8FieldRef12GetOneOrNoneE6ResultI7GetTypeI1TEERK1T) &root) const[\#](#_CPPv4I0ENK5arrow8FieldRef12GetOneOrNoneE6ResultI7GetTypeI1TEERK1T)\

    :   Get the single child matching this
        [FieldRef](#classarrow_1_1_field_ref).

        Return nullptr if none match, emit an error if multiple match.

    <!-- -->

    template\<typename T\>\
    inline [Result](support.html#_CPPv4I0EN5arrow6ResultE)\<[GetType](#_CPPv4I0EN5arrow8FieldRef7GetTypeE)\<[T](#_CPPv4I0ENK5arrow8FieldRef21GetOneOrNoneFlattenedE6ResultI7GetTypeI1TEERK1TP10MemoryPool)\>\> GetOneOrNoneFlattened(const [T](#_CPPv4I0ENK5arrow8FieldRef21GetOneOrNoneFlattenedE6ResultI7GetTypeI1TEERK1TP10MemoryPool) &root, [MemoryPool](memory.html#_CPPv4N5arrow10MemoryPoolE) \*pool = NULLPTR) const[\#](#_CPPv4I0ENK5arrow8FieldRef21GetOneOrNoneFlattenedE6ResultI7GetTypeI1TEERK1TP10MemoryPool)\

    :   Get the single child matching this
        [FieldRef](#classarrow_1_1_field_ref).

        Return nullptr if none match, emit an error if multiple match.
        Unlike
        [`FieldRef::GetOneOrNone`](#classarrow_1_1_field_ref_1a4d7a17c574154c12e1f849eebe7ec666),
        this variant is not zero-copy and the retrieved child's null
        bitmap is ANDed with its ancestors'

    Public Static Functions

    static [Result](support.html#_CPPv4I0EN5arrow6ResultE)\<[FieldRef](#classarrow_1_1_field_ref)\> FromDotPath(const std::string &dot_path)[\#](#_CPPv4N5arrow8FieldRef11FromDotPathERKNSt6stringE)\

    :   Parse a dot path into a [FieldRef](#classarrow_1_1_field_ref).

        dot_path = '.' name \| '\[' digit+ '\]' \| dot_path+

        Examples: ".alpha" =\>
        [FieldRef](#classarrow_1_1_field_ref)("alpha") "\[2\]" =\>
        FieldRef(2) ".beta\[3\]" =\>
        [FieldRef](#classarrow_1_1_field_ref)("beta", 3)
        "\[5\].gamma.delta\[7\]" =\>
        [FieldRef](#classarrow_1_1_field_ref)(5, "gamma", "delta", 7)
        ".hello world" =\> [FieldRef](#classarrow_1_1_field_ref)("hello
        world") R"(.\\\[y\\\]\\tho.\\)" =\>
        [FieldRef](#classarrow_1_1_field_ref)(R"(\[y\]\\tho.\\)")

        Note: When parsing a name, a '\' preceding any other character
        will be dropped from the resulting name. Therefore if a name
        must contain the characters '.', '\', or '\[' those must be
        escaped with a preceding '\'.

    struct Hash[\#](#_CPPv4N5arrow8FieldRef4HashE)\

    :        

        Public Functions

        inline size_t operator()(const [FieldRef](#classarrow_1_1_field_ref) &ref) const[\#](#_CPPv4NK5arrow8FieldRef4HashclERK8FieldRef)\

        :   

:::
::::

::: section
## Utilities[\#](#utilities)

class TypeVisitor[\#](#_CPPv4N5arrow11TypeVisitorE)\

:   Abstract type visitor class.

    Subclass this to create a visitor that can be used with the
    [DataType::Accept()](#classarrow_1_1_data_type_1a97571c4039e363f7ebcb09f7c789064a)
    method.

    Public Functions

    virtual \~TypeVisitor() = default[\#](#_CPPv4N5arrow11TypeVisitorD0Ev)\

    :   

    <!-- -->

    virtual [Status](support.html#_CPPv4N5arrow6StatusE) Visit(const [NullType](#classarrow_1_1_null_type) &type)[\#](#_CPPv4N5arrow11TypeVisitor5VisitERK8NullType)\

    :   

    <!-- -->

    virtual [Status](support.html#_CPPv4N5arrow6StatusE) Visit(const [BooleanType](#classarrow_1_1_boolean_type) &type)[\#](#_CPPv4N5arrow11TypeVisitor5VisitERK11BooleanType)\

    :   

    <!-- -->

    virtual [Status](support.html#_CPPv4N5arrow6StatusE) Visit(const [Int8Type](#classarrow_1_1_int8_type) &type)[\#](#_CPPv4N5arrow11TypeVisitor5VisitERK8Int8Type)\

    :   

    <!-- -->

    virtual [Status](support.html#_CPPv4N5arrow6StatusE) Visit(const [Int16Type](#classarrow_1_1_int16_type) &type)[\#](#_CPPv4N5arrow11TypeVisitor5VisitERK9Int16Type)\

    :   

    <!-- -->

    virtual [Status](support.html#_CPPv4N5arrow6StatusE) Visit(const [Int32Type](#classarrow_1_1_int32_type) &type)[\#](#_CPPv4N5arrow11TypeVisitor5VisitERK9Int32Type)\

    :   

    <!-- -->

    virtual [Status](support.html#_CPPv4N5arrow6StatusE) Visit(const [Int64Type](#classarrow_1_1_int64_type) &type)[\#](#_CPPv4N5arrow11TypeVisitor5VisitERK9Int64Type)\

    :   

    <!-- -->

    virtual [Status](support.html#_CPPv4N5arrow6StatusE) Visit(const [UInt8Type](#classarrow_1_1_u_int8_type) &type)[\#](#_CPPv4N5arrow11TypeVisitor5VisitERK9UInt8Type)\

    :   

    <!-- -->

    virtual [Status](support.html#_CPPv4N5arrow6StatusE) Visit(const [UInt16Type](#classarrow_1_1_u_int16_type) &type)[\#](#_CPPv4N5arrow11TypeVisitor5VisitERK10UInt16Type)\

    :   

    <!-- -->

    virtual [Status](support.html#_CPPv4N5arrow6StatusE) Visit(const [UInt32Type](#classarrow_1_1_u_int32_type) &type)[\#](#_CPPv4N5arrow11TypeVisitor5VisitERK10UInt32Type)\

    :   

    <!-- -->

    virtual [Status](support.html#_CPPv4N5arrow6StatusE) Visit(const [UInt64Type](#classarrow_1_1_u_int64_type) &type)[\#](#_CPPv4N5arrow11TypeVisitor5VisitERK10UInt64Type)\

    :   

    <!-- -->

    virtual [Status](support.html#_CPPv4N5arrow6StatusE) Visit(const [HalfFloatType](#classarrow_1_1_half_float_type) &type)[\#](#_CPPv4N5arrow11TypeVisitor5VisitERK13HalfFloatType)\

    :   

    <!-- -->

    virtual [Status](support.html#_CPPv4N5arrow6StatusE) Visit(const [FloatType](#classarrow_1_1_float_type) &type)[\#](#_CPPv4N5arrow11TypeVisitor5VisitERK9FloatType)\

    :   

    <!-- -->

    virtual [Status](support.html#_CPPv4N5arrow6StatusE) Visit(const [DoubleType](#classarrow_1_1_double_type) &type)[\#](#_CPPv4N5arrow11TypeVisitor5VisitERK10DoubleType)\

    :   

    <!-- -->

    virtual [Status](support.html#_CPPv4N5arrow6StatusE) Visit(const [StringType](#classarrow_1_1_string_type) &type)[\#](#_CPPv4N5arrow11TypeVisitor5VisitERK10StringType)\

    :   

    <!-- -->

    virtual [Status](support.html#_CPPv4N5arrow6StatusE) Visit(const [StringViewType](#classarrow_1_1_string_view_type) &type)[\#](#_CPPv4N5arrow11TypeVisitor5VisitERK14StringViewType)\

    :   

    <!-- -->

    virtual [Status](support.html#_CPPv4N5arrow6StatusE) Visit(const [BinaryType](#classarrow_1_1_binary_type) &type)[\#](#_CPPv4N5arrow11TypeVisitor5VisitERK10BinaryType)\

    :   

    <!-- -->

    virtual [Status](support.html#_CPPv4N5arrow6StatusE) Visit(const [BinaryViewType](#classarrow_1_1_binary_view_type) &type)[\#](#_CPPv4N5arrow11TypeVisitor5VisitERK14BinaryViewType)\

    :   

    <!-- -->

    virtual [Status](support.html#_CPPv4N5arrow6StatusE) Visit(const [LargeStringType](#classarrow_1_1_large_string_type) &type)[\#](#_CPPv4N5arrow11TypeVisitor5VisitERK15LargeStringType)\

    :   

    <!-- -->

    virtual [Status](support.html#_CPPv4N5arrow6StatusE) Visit(const [LargeBinaryType](#classarrow_1_1_large_binary_type) &type)[\#](#_CPPv4N5arrow11TypeVisitor5VisitERK15LargeBinaryType)\

    :   

    <!-- -->

    virtual [Status](support.html#_CPPv4N5arrow6StatusE) Visit(const [FixedSizeBinaryType](#classarrow_1_1_fixed_size_binary_type) &type)[\#](#_CPPv4N5arrow11TypeVisitor5VisitERK19FixedSizeBinaryType)\

    :   

    <!-- -->

    virtual [Status](support.html#_CPPv4N5arrow6StatusE) Visit(const [Date64Type](#classarrow_1_1_date64_type) &type)[\#](#_CPPv4N5arrow11TypeVisitor5VisitERK10Date64Type)\

    :   

    <!-- -->

    virtual [Status](support.html#_CPPv4N5arrow6StatusE) Visit(const [Date32Type](#classarrow_1_1_date32_type) &type)[\#](#_CPPv4N5arrow11TypeVisitor5VisitERK10Date32Type)\

    :   

    <!-- -->

    virtual [Status](support.html#_CPPv4N5arrow6StatusE) Visit(const [Time32Type](#classarrow_1_1_time32_type) &type)[\#](#_CPPv4N5arrow11TypeVisitor5VisitERK10Time32Type)\

    :   

    <!-- -->

    virtual [Status](support.html#_CPPv4N5arrow6StatusE) Visit(const [Time64Type](#classarrow_1_1_time64_type) &type)[\#](#_CPPv4N5arrow11TypeVisitor5VisitERK10Time64Type)\

    :   

    <!-- -->

    virtual [Status](support.html#_CPPv4N5arrow6StatusE) Visit(const [TimestampType](#classarrow_1_1_timestamp_type) &type)[\#](#_CPPv4N5arrow11TypeVisitor5VisitERK13TimestampType)\

    :   

    <!-- -->

    virtual [Status](support.html#_CPPv4N5arrow6StatusE) Visit(const [MonthDayNanoIntervalType](#classarrow_1_1_month_day_nano_interval_type) &type)[\#](#_CPPv4N5arrow11TypeVisitor5VisitERK24MonthDayNanoIntervalType)\

    :   

    <!-- -->

    virtual [Status](support.html#_CPPv4N5arrow6StatusE) Visit(const [MonthIntervalType](#classarrow_1_1_month_interval_type) &type)[\#](#_CPPv4N5arrow11TypeVisitor5VisitERK17MonthIntervalType)\

    :   

    <!-- -->

    virtual [Status](support.html#_CPPv4N5arrow6StatusE) Visit(const [DayTimeIntervalType](#classarrow_1_1_day_time_interval_type) &type)[\#](#_CPPv4N5arrow11TypeVisitor5VisitERK19DayTimeIntervalType)\

    :   

    <!-- -->

    virtual [Status](support.html#_CPPv4N5arrow6StatusE) Visit(const [DurationType](#classarrow_1_1_duration_type) &type)[\#](#_CPPv4N5arrow11TypeVisitor5VisitERK12DurationType)\

    :   

    <!-- -->

    virtual [Status](support.html#_CPPv4N5arrow6StatusE) Visit(const [Decimal32Type](#classarrow_1_1_decimal32_type) &type)[\#](#_CPPv4N5arrow11TypeVisitor5VisitERK13Decimal32Type)\

    :   

    <!-- -->

    virtual [Status](support.html#_CPPv4N5arrow6StatusE) Visit(const [Decimal64Type](#classarrow_1_1_decimal64_type) &type)[\#](#_CPPv4N5arrow11TypeVisitor5VisitERK13Decimal64Type)\

    :   

    <!-- -->

    virtual [Status](support.html#_CPPv4N5arrow6StatusE) Visit(const [Decimal128Type](#classarrow_1_1_decimal128_type) &type)[\#](#_CPPv4N5arrow11TypeVisitor5VisitERK14Decimal128Type)\

    :   

    <!-- -->

    virtual [Status](support.html#_CPPv4N5arrow6StatusE) Visit(const [Decimal256Type](#classarrow_1_1_decimal256_type) &type)[\#](#_CPPv4N5arrow11TypeVisitor5VisitERK14Decimal256Type)\

    :   

    <!-- -->

    virtual [Status](support.html#_CPPv4N5arrow6StatusE) Visit(const [ListType](#classarrow_1_1_list_type) &type)[\#](#_CPPv4N5arrow11TypeVisitor5VisitERK8ListType)\

    :   

    <!-- -->

    virtual [Status](support.html#_CPPv4N5arrow6StatusE) Visit(const [LargeListType](#classarrow_1_1_large_list_type) &type)[\#](#_CPPv4N5arrow11TypeVisitor5VisitERK13LargeListType)\

    :   

    <!-- -->

    virtual [Status](support.html#_CPPv4N5arrow6StatusE) Visit(const [ListViewType](#classarrow_1_1_list_view_type) &scalar)[\#](#_CPPv4N5arrow11TypeVisitor5VisitERK12ListViewType)\

    :   

    <!-- -->

    virtual [Status](support.html#_CPPv4N5arrow6StatusE) Visit(const [LargeListViewType](#classarrow_1_1_large_list_view_type) &scalar)[\#](#_CPPv4N5arrow11TypeVisitor5VisitERK17LargeListViewType)\

    :   

    <!-- -->

    virtual [Status](support.html#_CPPv4N5arrow6StatusE) Visit(const [MapType](#classarrow_1_1_map_type) &type)[\#](#_CPPv4N5arrow11TypeVisitor5VisitERK7MapType)\

    :   

    <!-- -->

    virtual [Status](support.html#_CPPv4N5arrow6StatusE) Visit(const [FixedSizeListType](#classarrow_1_1_fixed_size_list_type) &type)[\#](#_CPPv4N5arrow11TypeVisitor5VisitERK17FixedSizeListType)\

    :   

    <!-- -->

    virtual [Status](support.html#_CPPv4N5arrow6StatusE) Visit(const [StructType](#classarrow_1_1_struct_type) &type)[\#](#_CPPv4N5arrow11TypeVisitor5VisitERK10StructType)\

    :   

    <!-- -->

    virtual [Status](support.html#_CPPv4N5arrow6StatusE) Visit(const [SparseUnionType](#classarrow_1_1_sparse_union_type) &type)[\#](#_CPPv4N5arrow11TypeVisitor5VisitERK15SparseUnionType)\

    :   

    <!-- -->

    virtual [Status](support.html#_CPPv4N5arrow6StatusE) Visit(const [DenseUnionType](#classarrow_1_1_dense_union_type) &type)[\#](#_CPPv4N5arrow11TypeVisitor5VisitERK14DenseUnionType)\

    :   

    <!-- -->

    virtual [Status](support.html#_CPPv4N5arrow6StatusE) Visit(const [DictionaryType](#classarrow_1_1_dictionary_type) &type)[\#](#_CPPv4N5arrow11TypeVisitor5VisitERK14DictionaryType)\

    :   

    <!-- -->

    virtual [Status](support.html#_CPPv4N5arrow6StatusE) Visit(const [RunEndEncodedType](#classarrow_1_1_run_end_encoded_type) &type)[\#](#_CPPv4N5arrow11TypeVisitor5VisitERK17RunEndEncodedType)\

    :   

    <!-- -->

    virtual [Status](support.html#_CPPv4N5arrow6StatusE) Visit(const [ExtensionType](#classarrow_1_1_extension_type) &type)[\#](#_CPPv4N5arrow11TypeVisitor5VisitERK13ExtensionType)\

    :   

:::
::::::::::::::

[](thread.html)

previous

Thread (management)

[](array.html)

next

Arrays

On this page

-   [Factory functions](#factory-functions)
-   [Concrete type subclasses](#concrete-type-subclasses)
    -   [Primitive](#primitive)
    -   [Temporal](#temporal)
    -   [Binary-like](#binary-like)
    -   [Nested](#nested)
    -   [Dictionary-encoded](#dictionary-encoded)
    -   [Extension types](#extension-types)
-   [Fields and Schemas](#fields-and-schemas)
    -   [Helpers for looking up fields](#helpers-for-looking-up-fields)
-   [Utilities](#utilities)

[Edit on
GitHub](https://github.com/apache/arrow/edit/main/docs/source/cpp/api/datatype.rst)
